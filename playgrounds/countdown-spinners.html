<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Director's Palette — Countdown Spinner Playground</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    /* Electric Amber theme — matches Director's Palette app */
    --bg: oklch(0.12 0.015 250);
    --card: oklch(0.15 0.015 250);
    --card-hover: oklch(0.18 0.02 250);
    --primary: oklch(0.75 0.16 75);
    --primary-dim: oklch(0.55 0.12 75);
    --primary-glow: oklch(0.8 0.18 75);
    --accent: oklch(0.65 0.12 195);
    --text: oklch(0.93 0.01 80);
    --text-muted: oklch(0.60 0.02 80);
    --border: oklch(0.28 0.02 250);
    --surface: oklch(0.20 0.015 250);
    --destructive: oklch(0.55 0.22 25);
    --success: oklch(0.6 0.18 145);
    --radius: 0.625rem;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, sans-serif;
    min-height: 100vh;
    padding: 1.5rem;
  }

  header {
    text-align: center;
    margin-bottom: 1.5rem;
  }
  header h1 {
    font-size: 1.5rem;
    font-weight: 700;
    letter-spacing: -0.025em;
    margin-bottom: 0.25rem;
    color: var(--primary);
  }
  header p { color: var(--text-muted); font-size: 0.8rem; }

  .controls-bar {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
    margin-bottom: 1.5rem;
    padding: 0.75rem 1rem;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
  }
  .controls-bar label {
    font-size: 0.75rem;
    color: var(--text-muted);
    display: flex;
    align-items: center;
    gap: 0.35rem;
  }
  .controls-bar input[type="number"],
  .controls-bar input[type="text"] {
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 0.375rem;
    padding: 0.3rem 0.5rem;
    width: 5rem;
    font-size: 0.75rem;
  }
  .controls-bar input[type="text"] { width: 10rem; }

  .btn {
    background: var(--primary);
    color: oklch(0.15 0.02 75);
    border: none;
    border-radius: 0.375rem;
    padding: 0.4rem 1rem;
    font-size: 0.8rem;
    font-weight: 600;
    cursor: pointer;
    transition: filter 0.2s;
  }
  .btn:hover { filter: brightness(1.15); }
  .btn-outline {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-muted);
  }
  .btn-outline:hover { border-color: var(--primary); color: var(--text); }

  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 0.75rem;
    max-width: 100%;
  }

  .spinner-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.75rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    transition: border-color 0.2s, box-shadow 0.2s;
    position: relative;
  }
  .spinner-card:hover {
    border-color: var(--primary-dim);
    box-shadow: 0 2px 12px oklch(0.2 0.05 75 / 0.3);
  }
  .spinner-card .card-number {
    position: absolute;
    top: 0.4rem;
    left: 0.5rem;
    font-size: 0.6rem;
    color: var(--text-muted);
    font-weight: 600;
  }
  .spinner-card h3 {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: -0.015em;
    text-align: center;
  }
  .spinner-area {
    width: 140px;
    height: 140px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  .spinner-area svg { overflow: visible; }

  .spinner-meta {
    text-align: center;
    font-size: 0.7rem;
    color: var(--text-muted);
    line-height: 1.4;
  }
  .spinner-meta .time-left {
    font-size: 0.85rem;
    font-weight: 700;
    color: var(--text);
    font-variant-numeric: tabular-nums;
  }
  .spinner-meta .model-name {
    color: var(--primary);
    font-weight: 500;
  }

  /* Prompt output */
  .prompt-section {
    margin-top: 1.5rem;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 1rem;
  }
  .prompt-section h2 {
    font-size: 0.85rem;
    margin-bottom: 0.5rem;
    color: var(--text-muted);
  }
  .prompt-output {
    font-family: 'SF Mono', 'Cascadia Code', monospace;
    font-size: 0.75rem;
    color: var(--text);
    line-height: 1.6;
    white-space: pre-wrap;
    min-height: 3rem;
  }
  .copy-btn {
    margin-top: 0.5rem;
    font-size: 0.7rem;
    padding: 0.3rem 0.75rem;
  }

  @keyframes spin { to { transform: rotate(360deg); } }
  @keyframes pulse { 0%,100% { opacity: 0.4; } 50% { opacity: 1; } }
</style>
</head>
<body>

<header>
  <h1>Countdown Spinner Playground</h1>
  <p>20 loading indicator variants for Director's Palette</p>
</header>

<div class="controls-bar">
  <label>Time (s): <input type="number" id="globalTime" value="15" min="5" max="120"></label>
  <label>Model: <input type="text" id="globalModel" value="flux-1.1-pro"></label>
  <button class="btn" onclick="startAll()">Start All</button>
  <button class="btn btn-outline" onclick="resetAll()">Reset All</button>
</div>

<div class="grid" id="spinnerGrid"></div>

<div class="prompt-section">
  <h2>Prompt Output</h2>
  <div class="prompt-output" id="promptOutput">Adjust controls and click "Start All" to preview all spinners.</div>
  <button class="btn copy-btn" onclick="copyPrompt()">Copy</button>
</div>

<script>
// ─── Color palette constants (Electric Amber theme) ───
const C = {
  // Backgrounds (hue 250 blue-gray)
  bg:         'oklch(0.12 0.015 250)',
  card:       'oklch(0.15 0.015 250)',
  surface:    'oklch(0.20 0.015 250)',
  surfaceAlt: 'oklch(0.22 0.02 250)',
  // Primary (hue 75 electric amber)
  primary:    'oklch(0.75 0.16 75)',
  primaryDim: 'oklch(0.55 0.12 75)',
  primaryGlow:'oklch(0.8 0.18 75)',
  primaryFg:  'oklch(0.15 0.02 75)',
  // Accent (hue 195 teal)
  accent:     'oklch(0.65 0.12 195)',
  // Text (hue 80 warm)
  text:       'oklch(0.93 0.01 80)',
  textMuted:  'oklch(0.60 0.02 80)',
  // Borders
  border:     'oklch(0.28 0.02 250)',
  borderLight:'oklch(0.35 0.03 250)',
  // Tracks / unfilled
  track:      'oklch(0.22 0.02 250)',
  trackLight: 'oklch(0.30 0.025 250)',
  // Semantic
  success:    'oklch(0.6 0.18 145)',
  destructive:'oklch(0.55 0.22 25)',
};

// ─── State ───
const SPINNER_COUNT = 20;
const state = {
  duration: 15,
  model: 'flux-1.1-pro',
  running: false,
  startTime: null,
  selected: null,
  animFrameId: null,
};

const spinnerNames = [
  'Circular Progress Ring',
  'Film Reel Spin',
  'Clapperboard',
  'Film Strip',
  'Meter Gauge',
  'Radial Wipe',
  'Neon Ring Pulse',
  'Director Chair Fill',
  'Spotlight Sweep',
  'Ticket Stub Reveal',
  'Countdown Numbers',
  'Film Grain Shimmer',
  'Camera Iris',
  'Popcorn Bucket',
  'Star Rating Fill',
  'Projector Light',
  'Scene Slate',
  'Reel-to-Reel Tape',
  'Marquee Lights',
  'Golden Spiral',
];

// ─── Build grid ───
const grid = document.getElementById('spinnerGrid');
spinnerNames.forEach((name, i) => {
  const card = document.createElement('div');
  card.className = 'spinner-card';
  card.dataset.index = i;
  card.innerHTML = `
    <span class="card-number">#${i + 1}</span>
    <h3>${name}</h3>
    <div class="spinner-area" id="area-${i}"></div>
    <div class="spinner-meta">
      <div class="time-left" id="time-${i}">0:00</div>
      <div class="model-name" id="model-${i}">${state.model}</div>
    </div>
  `;
  card.addEventListener('click', () => selectSpinner(i));
  grid.appendChild(card);
});

function selectSpinner(idx) {
  document.querySelectorAll('.spinner-card').forEach(c => c.style.borderColor = '');
  const card = document.querySelector(`.spinner-card[data-index="${idx}"]`);
  if (card) card.style.borderColor = C.primary;
  state.selected = idx;
  updatePrompt();
}

// ─── Render functions ───
// p can exceed 1.0 — each spinner handles "overtime" visually
function renderSpinner(idx, progress) {
  const area = document.getElementById(`area-${idx}`);
  if (!area) return;
  const p = Math.max(0, progress); // DO NOT clamp to 1 — allow overflow
  switch(idx) {
    case 0: renderCircularRing(area, p); break;
    case 1: renderFilmReel(area, p); break;
    case 2: renderClapperboard(area, p); break;
    case 3: renderFilmStrip(area, p); break;
    case 4: renderMeterGauge(area, p); break;
    case 5: renderRadialWipe(area, p); break;
    case 6: renderNeonRing(area, p); break;
    case 7: renderDirectorChair(area, p); break;
    case 8: renderSpotlight(area, p); break;
    case 9: renderTicketStub(area, p); break;
    case 10: renderCountdownNumbers(area, p); break;
    case 11: renderFilmGrain(area, p); break;
    case 12: renderCameraIris(area, p); break;
    case 13: renderPopcornBucket(area, p); break;
    case 14: renderStarRating(area, p); break;
    case 15: renderProjectorLight(area, p); break;
    case 16: renderSceneSlate(area, p); break;
    case 17: renderReelToReel(area, p); break;
    case 18: renderMarqueeLights(area, p); break;
    case 19: renderGoldenSpiral(area, p); break;
  }
}

/* 1. Circular Progress Ring — overtime: ring pulses, shows "Still working..." */
function renderCircularRing(el, p) {
  const r = 50, c = Math.PI * 2 * r;
  const clamped = Math.min(1, p);
  const offset = c * (1 - clamped);
  const overtime = p > 1;
  const pulseOp = overtime ? 0.5 + 0.5 * Math.sin(Date.now() / 300) : 1;
  const ringColor = overtime ? `oklch(0.75 0.16 75 / ${pulseOp})` : C.primary;
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 120">
    <circle cx="60" cy="60" r="${r}" fill="none" stroke="${C.track}" stroke-width="8"/>
    <circle cx="60" cy="60" r="${r}" fill="none" stroke="${ringColor}" stroke-width="8"
      stroke-dasharray="${c}" stroke-dashoffset="${offset}"
      stroke-linecap="round" transform="rotate(-90 60 60)"/>
    <text x="60" y="${overtime?58:65}" text-anchor="middle" fill="${C.text}" font-size="${overtime?18:22}" font-weight="700" font-family="system-ui">${Math.round(clamped*100)}%</text>
    ${overtime?`<text x="60" y="78" text-anchor="middle" fill="${C.primary}" font-size="9" font-family="system-ui">Still working...</text>`:''}
  </svg>`;
}

/* 2. Film Reel Spin — overtime: spins faster and faster */
function renderFilmReel(el, p) {
  const overtime = p > 1;
  const speed = overtime ? 720 + (p - 1) * 2000 : p * 720; // accelerates in overtime
  const rot = speed;
  const clamped = Math.min(1, p);
  const holes = Array.from({length:8}, (_,i) => {
    const a = (i/8)*Math.PI*2;
    return `<circle cx="${50+25*Math.cos(a)}" cy="${50+25*Math.sin(a)}" r="5" fill="${C.bg}"/>`;
  }).join('');
  const wobble = overtime ? Math.sin(Date.now()/100) * 2 : 0;
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 100 100" style="transform:rotate(${rot}deg) translateX(${wobble}px)">
    <circle cx="50" cy="50" r="45" fill="${C.trackLight}" stroke="${overtime?C.accent:C.primary}" stroke-width="3"/>
    <circle cx="50" cy="50" r="12" fill="${C.bg}" stroke="${C.primaryDim}" stroke-width="2"/>
    ${holes}
    <circle cx="50" cy="50" r="45" fill="none" stroke="${C.primary}" stroke-width="4"
      stroke-dasharray="${Math.PI*90}" stroke-dashoffset="${Math.PI*90*(1-clamped)}"
      stroke-linecap="round" transform="rotate(-90 50 50)"/>
  </svg>`;
}

/* 3. Clapperboard — overtime: clapper keeps snapping open/shut */
function renderClapperboard(el, p) {
  const overtime = p > 1;
  let clapAngle;
  if (overtime) {
    // Repeatedly clap open and shut
    clapAngle = Math.sin(Date.now() / 200) * -25;
  } else {
    clapAngle = p < 0.1 ? (p/0.1)*-30 : p < 0.2 ? -30+(((p-0.1)/0.1)*30) : 0;
  }
  const clamped = Math.min(1, p);
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 100 100">
    <rect x="10" y="35" width="80" height="55" rx="3" fill="${C.surface}" stroke="${overtime?C.accent:C.primary}" stroke-width="2"/>
    <rect x="10" y="80" width="${clamped*80}" height="6" rx="2" fill="${C.primary}"/>
    <g transform="rotate(${clapAngle} 10 35)">
      <rect x="10" y="20" width="80" height="18" rx="2" fill="${C.trackLight}" stroke="${overtime?C.accent:C.primary}" stroke-width="2"/>
      ${Array.from({length:5}, (_,i) => `<rect x="${15+i*16}" y="20" width="8" height="18" fill="${i%2===0?C.bg:C.trackLight}" rx="1"/>`).join('')}
    </g>
    <text x="50" y="60" text-anchor="middle" fill="${C.text}" font-size="14" font-weight="700" font-family="system-ui">${overtime?'OVERTIME':Math.round(clamped*100)+'%'}</text>
    ${overtime?`<text x="50" y="74" text-anchor="middle" fill="${C.primary}" font-size="9" font-family="system-ui">Hang tight...</text>`:''}
  </svg>`;
}

/* 4. Film Strip — overtime: all frames filled, strip scrolls/jitters */
function renderFilmStrip(el, p) {
  const frames = 5;
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const filledFrames = Math.floor(clamped * frames);
  const partial = (clamped * frames) - filledFrames;
  const jitterY = overtime ? Math.sin(Date.now() / 150) * 3 : 0;
  let rects = '';
  for(let i = 0; i < frames; i++) {
    const y = 5 + i * 22 + jitterY;
    const fill = i < filledFrames ? C.primary :
                 i === filledFrames ? `oklch(${0.3+partial*0.45} ${0.04+partial*0.12} 75)` :
                 C.surface;
    // In overtime, all frames pulse
    const overtimeFill = overtime ? (Math.sin(Date.now()/200 + i) > 0 ? C.primary : C.primaryDim) : fill;
    rects += `<rect x="20" y="${y}" width="60" height="18" rx="2" fill="${overtimeFill}" stroke="${C.borderLight}" stroke-width="1"/>`;
    rects += `<circle cx="12" cy="${y+9}" r="3" fill="${C.bg}"/>`;
    rects += `<circle cx="88" cy="${y+9}" r="3" fill="${C.bg}"/>`;
  }
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 100 120">
    <rect x="6" y="0" width="88" height="117" rx="3" fill="none" stroke="${overtime?C.accent:C.borderLight}" stroke-width="2"/>
    ${rects}
  </svg>`;
}

/* 5. Meter Gauge — overtime: needle wobbles past the red zone */
function renderMeterGauge(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const startAngle = -135, endAngle = 135;
  // In overtime, needle oscillates near/past the max
  const wobble = overtime ? Math.sin(Date.now() / 150) * 10 : 0;
  const angle = startAngle + (endAngle - startAngle) * clamped + wobble;
  const rad = angle * Math.PI / 180;
  const cx = 60, cy = 65, nr = 40;
  const nx = cx + nr * Math.cos(rad), ny = cy + nr * Math.sin(rad);
  const arcStart = startAngle * Math.PI / 180;
  const x1 = cx + 45*Math.cos(arcStart), y1 = cy + 45*Math.sin(arcStart);
  const x2 = cx + 45*Math.cos(rad), y2 = cy + 45*Math.sin(rad);
  const largeArc = (angle - startAngle) > 180 ? 1 : 0;
  const needleColor = overtime ? C.destructive : C.text;
  el.innerHTML = `<svg width="130" height="120" viewBox="0 0 120 110">
    <path d="M ${cx+45*Math.cos(arcStart)} ${cy+45*Math.sin(arcStart)} A 45 45 0 ${largeArc} 1 ${cx+45*Math.cos(endAngle*Math.PI/180)} ${cy+45*Math.sin(endAngle*Math.PI/180)}"
      fill="none" stroke="${C.track}" stroke-width="8" stroke-linecap="round"/>
    <path d="M ${x1} ${y1} A 45 45 0 ${largeArc} 1 ${x2} ${y2}"
      fill="none" stroke="${overtime?C.accent:C.primary}" stroke-width="8" stroke-linecap="round"/>
    <line x1="${cx}" y1="${cy}" x2="${nx}" y2="${ny}" stroke="${needleColor}" stroke-width="3" stroke-linecap="round"/>
    <circle cx="${cx}" cy="${cy}" r="5" fill="${overtime?C.accent:C.primary}"/>
    <text x="${cx}" y="${cy+20}" text-anchor="middle" fill="${overtime?C.accent:C.textMuted}" font-size="11" font-family="system-ui">${overtime?'OVER':Math.round(clamped*100)+'%'}</text>
  </svg>`;
}

/* 6. Radial Wipe — overtime: full circle pulses/breathes */
function renderRadialWipe(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const angle = clamped * 360;
  const largeArc = angle > 180 ? 1 : 0;
  const rad = (angle - 90) * Math.PI / 180;
  const ex = 60 + 50 * Math.cos(rad);
  const ey = 60 + 50 * Math.sin(rad);
  const pathD = angle >= 360
    ? `M 60 60 m 0 -50 a 50 50 0 1 1 0 100 a 50 50 0 1 1 0 -100 Z`
    : `M 60 60 L 60 10 A 50 50 0 ${largeArc} 1 ${ex} ${ey} Z`;
  const breathe = overtime ? 0.25 + 0.2 * Math.sin(Date.now() / 400) : 0.45;
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 120">
    <circle cx="60" cy="60" r="50" fill="${C.surface}" stroke="${overtime?C.accent:C.borderLight}" stroke-width="2"/>
    <path d="${pathD}" fill="oklch(0.75 0.16 75 / ${breathe})"/>
    <circle cx="60" cy="60" r="20" fill="${C.card}"/>
    <text x="60" y="${overtime?58:65}" text-anchor="middle" fill="${C.text}" font-size="14" font-weight="700" font-family="system-ui">100%</text>
    ${overtime?`<text x="60" y="73" text-anchor="middle" fill="${C.accent}" font-size="8" font-family="system-ui">Processing...</text>`:''}
  </svg>`;
}

/* 7. Neon Ring Pulse — overtime: ring strobes faster, glow intensifies */
function renderNeonRing(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const r = 46, c = Math.PI*2*r;
  const speed = overtime ? 80 : 200;
  const pulseOp = 0.3 + Math.sin(Date.now()/speed)*0.4;
  const glowSize = overtime ? 12 : 6;
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 120">
    <circle cx="60" cy="60" r="${r}" fill="none" stroke="oklch(0.75 0.16 75 / ${pulseOp})" stroke-width="12"/>
    <circle cx="60" cy="60" r="${r}" fill="none" stroke="${C.primaryGlow}" stroke-width="4"
      stroke-dasharray="${c}" stroke-dashoffset="${c*(1-clamped)}"
      stroke-linecap="round" transform="rotate(-90 60 60)"
      style="filter:drop-shadow(0 0 ${glowSize}px ${C.primaryGlow})"/>
    <text x="60" y="${overtime?58:65}" text-anchor="middle" fill="${C.text}" font-size="${overtime?16:20}" font-weight="700"
      font-family="system-ui" style="filter:drop-shadow(0 0 4px ${C.primary})">${Math.round(clamped*100)}%</text>
    ${overtime?`<text x="60" y="76" text-anchor="middle" fill="${C.primaryGlow}" font-size="9" font-family="system-ui">Almost there</text>`:''}
  </svg>`;
}

/* 8. Director Chair Fill — overtime: chair glows, text says DIRECTOR */
function renderDirectorChair(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const fillH = 50 * clamped;
  const glow = overtime ? `filter:drop-shadow(0 0 ${4+Math.sin(Date.now()/200)*3}px ${C.primary})` : '';
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 100 100" style="${glow}">
    <line x1="25" y1="25" x2="20" y2="90" stroke="${C.primaryDim}" stroke-width="4" stroke-linecap="round"/>
    <line x1="75" y1="25" x2="80" y2="90" stroke="${C.primaryDim}" stroke-width="4" stroke-linecap="round"/>
    <line x1="30" y1="55" x2="70" y2="55" stroke="${C.primaryDim}" stroke-width="3"/>
    <rect x="22" y="20" width="56" height="30" rx="3" fill="${C.surface}" stroke="${C.primaryDim}" stroke-width="2"/>
    <clipPath id="chairClip"><rect x="22" y="${50-fillH}" width="56" height="${fillH}"/></clipPath>
    <rect x="22" y="20" width="56" height="30" rx="3" fill="${C.primary}" clip-path="url(#chairClip)"/>
    <rect x="25" y="52" width="50" height="8" rx="2" fill="oklch(0.75 0.16 75 / ${0.3+clamped*0.7})"/>
    <text x="50" y="42" text-anchor="middle" fill="${C.primaryFg}" font-size="${overtime?8:11}" font-weight="700" font-family="system-ui">${overtime?'DIRECTOR':Math.round(clamped*100)+'%'}</text>
  </svg>`;
}

/* 9. Spotlight Sweep — overtime: spotlight swings back and forth searching */
function renderSpotlight(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  let angle;
  if (overtime) {
    angle = Math.sin(Date.now() / 400) * 40; // swings left-right
  } else {
    angle = -40 + p * 80;
  }
  const rad = angle * Math.PI / 180;
  const bx = 60 + 80 * Math.sin(rad);
  const by = 110;
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 120">
    <defs>
      <radialGradient id="spotGrad" cx="50%" cy="0%" r="80%">
        <stop offset="0%" stop-color="oklch(0.85 0.14 75 / 0.5)"/>
        <stop offset="100%" stop-color="oklch(0.85 0.14 75 / 0)"/>
      </radialGradient>
    </defs>
    <polygon points="55,15 65,15 ${bx+25},${by} ${bx-25},${by}" fill="url(#spotGrad)" opacity="${overtime?0.8:0.4+clamped*0.6}"/>
    <ellipse cx="60" cy="12" rx="14" ry="8" fill="${C.trackLight}"/>
    <circle cx="60" cy="12" r="6" fill="${overtime?C.primaryGlow:C.primary}"/>
    <rect x="10" y="105" width="100" height="6" rx="3" fill="${C.track}"/>
    <rect x="10" y="105" width="100" height="6" rx="3" fill="${C.primary}"/>
  </svg>`;
}

/* 10. Ticket Stub Reveal — overtime: ticket fully revealed, shimmers */
function renderTicketStub(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const revealH = 90 * clamped;
  const shimmer = overtime ? 0.25 + 0.15 * Math.sin(Date.now() / 250) : 0.35;
  el.innerHTML = `<svg width="110" height="120" viewBox="0 0 90 110">
    <defs>
      <clipPath id="ticketReveal"><rect x="0" y="${100-revealH}" width="90" height="${revealH+10}"/></clipPath>
    </defs>
    <rect x="10" y="10" width="70" height="90" rx="6" fill="${C.surface}" stroke="${overtime?C.primary:C.borderLight}" stroke-width="1.5"/>
    <line x1="10" y1="70" x2="80" y2="70" stroke="${C.borderLight}" stroke-width="1" stroke-dasharray="4 3"/>
    <rect x="10" y="10" width="70" height="90" rx="6" fill="oklch(0.75 0.16 75 / ${shimmer})" clip-path="url(#ticketReveal)"/>
    <text x="45" y="45" text-anchor="middle" fill="${C.text}" font-size="10" font-weight="600" font-family="system-ui">${overtime?'HOLD TIGHT':'ADMIT ONE'}</text>
    <text x="45" y="62" text-anchor="middle" fill="${C.primaryGlow}" font-size="18" font-weight="700" font-family="system-ui">${overtime?'100%':Math.round(clamped*100)+'%'}</text>
    <circle cx="10" cy="70" r="5" fill="${C.bg}"/>
    <circle cx="80" cy="70" r="5" fill="${C.bg}"/>
  </svg>`;
}

/* 11. Countdown Numbers — overtime: shows +Xs over, pulses */
function renderCountdownNumbers(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const remaining = Math.ceil((1 - clamped) * state.duration);
  const overSeconds = overtime ? Math.floor((p - 1) * state.duration) : 0;
  const scale = overtime ? 0.9 + 0.1 * Math.sin(Date.now() / 200) : 0.8 + 0.4 * Math.abs(Math.sin(p * Math.PI * 4));
  const opacity = p >= 1 ? 1 : 0.6 + 0.4 * Math.abs(Math.sin(p * Math.PI * 6));
  let display, subtitle, color;
  if (overtime) {
    display = `+${overSeconds}s`;
    subtitle = 'over estimate';
    color = C.accent;
  } else if (clamped >= 1) {
    display = '✓';
    subtitle = '';
    color = C.success;
  } else {
    display = remaining;
    subtitle = 'seconds left';
    color = C.primary;
  }
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 120">
    <circle cx="60" cy="60" r="50" fill="none" stroke="${overtime?C.accent:C.trackLight}" stroke-width="3"/>
    <text x="60" y="72" text-anchor="middle" fill="${color}"
      font-size="${overtime?32:clamped>=1?28:42}" font-weight="800" font-family="system-ui"
      opacity="${opacity}" transform="scale(${scale})" transform-origin="60 60">${display}</text>
    ${subtitle?`<text x="60" y="95" text-anchor="middle" fill="${C.textMuted}" font-size="9" font-family="system-ui">${subtitle}</text>`:''}
  </svg>`;
}

/* 12. Film Grain Shimmer — overtime: grain gets heavier, bar overflows */
function renderFilmGrain(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const canvas = el.querySelector('canvas') || document.createElement('canvas');
  canvas.width = 120; canvas.height = 120;
  if (!el.contains(canvas)) { el.innerHTML = ''; el.appendChild(canvas); }
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#0f1520';
  ctx.fillRect(0, 0, 120, 120);
  // In overtime, grain gets HEAVIER (opposite of normal)
  const grainIntensity = overtime ? 20 + Math.random() * 30 : 40 * (1-clamped);
  const imgData = ctx.getImageData(0, 0, 120, 120);
  for (let i = 0; i < imgData.data.length; i += 4) {
    const noise = Math.random() * grainIntensity;
    imgData.data[i] = imgData.data[i] + noise * 1.2;
    imgData.data[i+1] = imgData.data[i+1] + noise * 0.8;
    imgData.data[i+2] = imgData.data[i+2] + noise * 0.3;
  }
  ctx.putImageData(imgData, 0, 0);
  // Progress bar — full in overtime, pulses
  const barColor = overtime ? (Math.sin(Date.now()/200) > 0 ? '#c9a040' : '#5ba8b5') : '#c9a040';
  ctx.fillStyle = barColor;
  ctx.fillRect(10, 100, 100 * clamped, 8);
  ctx.strokeStyle = '#3a3545';
  ctx.strokeRect(10, 100, 100, 8);
  ctx.fillStyle = '#f0e8d0';
  ctx.font = 'bold 22px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(overtime ? '100%' : `${Math.round(clamped*100)}%`, 60, 58);
  if (overtime) {
    ctx.fillStyle = '#5ba8b5';
    ctx.font = '11px system-ui';
    ctx.fillText('Still rendering...', 60, 78);
  }
}

/* 13. Camera Iris — overtime: iris twitches open/closed */
function renderCameraIris(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const blades = 6;
  const twitch = overtime ? Math.sin(Date.now() / 150) * 8 : 0;
  const openRadius = Math.min(50, 8 + 42 * clamped + twitch);
  let paths = '';
  for (let i = 0; i < blades; i++) {
    const angle = (i / blades) * Math.PI * 2;
    const nextAngle = ((i+1) / blades) * Math.PI * 2;
    const outerR = 55;
    const innerR = Math.max(5, 50 - openRadius);
    const x1 = 60 + innerR * Math.cos(angle), y1 = 60 + innerR * Math.sin(angle);
    const x2 = 60 + outerR * Math.cos(angle + 0.15), y2 = 60 + outerR * Math.sin(angle + 0.15);
    const x3 = 60 + outerR * Math.cos(nextAngle - 0.15), y3 = 60 + outerR * Math.sin(nextAngle - 0.15);
    const x4 = 60 + innerR * Math.cos(nextAngle), y4 = 60 + innerR * Math.sin(nextAngle);
    paths += `<path d="M${x1},${y1} L${x2},${y2} L${x3},${y3} L${x4},${y4} Z"
      fill="${C.track}" stroke="${C.borderLight}" stroke-width="0.5"/>`;
  }
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 120">
    <circle cx="60" cy="60" r="55" fill="${C.card}" stroke="${overtime?C.accent:C.borderLight}" stroke-width="2"/>
    ${paths}
    <circle cx="60" cy="60" r="${openRadius}" fill="oklch(0.75 0.16 75 / 0.25)"/>
    <text x="60" y="65" text-anchor="middle" fill="${C.text}" font-size="14" font-weight="700" font-family="system-ui">${overtime?'100%':Math.round(clamped*100)+'%'}</text>
  </svg>`;
}

/* 14. Popcorn Bucket — overtime: popcorn spills over the top! */
function renderPopcornBucket(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const fillY = 85 - 55 * clamped;
  const baseKernels = Math.floor(clamped * 12);
  // In overtime, extra kernels spill above the rim
  const spillKernels = overtime ? Math.min(8, Math.floor((p - 1) * 20)) : 0;
  let kernels = '';
  // Normal kernels inside bucket
  for (let i = 0; i < baseKernels; i++) {
    const kx = 35 + (i % 4) * 13 + Math.sin(i*2)*3;
    const ky = fillY - 2 - Math.floor(i/4)*10 + Math.cos(i*3)*2;
    kernels += `<circle cx="${kx}" cy="${ky}" r="5" fill="oklch(0.85 0.12 75)" stroke="oklch(0.7 0.1 75)" stroke-width="0.5"/>`;
  }
  // Spilling kernels above the rim
  for (let i = 0; i < spillKernels; i++) {
    const kx = 30 + Math.sin(i * 1.7 + Date.now()/500) * 20 + i * 5;
    const ky = 28 - i * 3 + Math.sin(Date.now()/300 + i * 2) * 2;
    // Some kernels falling to the sides
    const fallX = kx + (i > 4 ? (i % 2 === 0 ? -15 : 15) : 0);
    const fallY = ky + (i > 4 ? (Date.now()/20 % 40) : 0);
    kernels += `<circle cx="${Math.min(90, Math.max(10, fallX))}" cy="${Math.min(95, fallY)}" r="4.5" fill="oklch(0.85 0.12 75)" stroke="oklch(0.7 0.1 75)" stroke-width="0.5"/>`;
  }
  el.innerHTML = `<svg width="110" height="120" viewBox="0 0 100 100">
    <path d="M 25 30 L 20 88 Q 20 92 24 92 L 76 92 Q 80 92 80 88 L 75 30 Z"
      fill="oklch(0.55 0.2 25)" stroke="oklch(0.4 0.15 25)" stroke-width="2"/>
    <path d="M 35 30 L 33 92" stroke="oklch(0.9 0.04 75)" stroke-width="3"/>
    <path d="M 50 30 L 50 92" stroke="oklch(0.9 0.04 75)" stroke-width="3"/>
    <path d="M 65 30 L 67 92" stroke="oklch(0.9 0.04 75)" stroke-width="3"/>
    <clipPath id="bucketClip"><path d="M 25 30 L 20 88 Q 20 92 24 92 L 76 92 Q 80 92 80 88 L 75 30 Z"/></clipPath>
    <rect x="18" y="${fillY}" width="64" height="${92-fillY}" fill="oklch(0.85 0.1 75 / 0.5)" clip-path="url(#bucketClip)"/>
    ${kernels}
    <text x="50" y="${overtime?12:18}" text-anchor="middle" fill="${overtime?C.accent:C.primary}" font-size="${overtime?11:14}" font-weight="700" font-family="system-ui">${overtime?'Overflowing!':Math.round(clamped*100)+'%'}</text>
  </svg>`;
}

/* 15. Star Rating Fill — overtime: all stars glow/pulse */
function renderStarRating(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const totalStars = 5;
  const filledStars = clamped * totalStars;
  let stars = '';
  for (let i = 0; i < totalStars; i++) {
    const cx = 15 + i * 22, cy = 55;
    const starPath = starSvgPath(cx, cy, 10, 5);
    const fillAmount = Math.min(1, Math.max(0, filledStars - i));
    if (overtime) {
      // All stars filled, pulsing glow
      const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 200 + i * 0.5);
      stars += `<path d="${starPath}" fill="${C.primary}" stroke="${C.primaryGlow}" stroke-width="1.5" opacity="${pulse}"
        style="filter:drop-shadow(0 0 3px ${C.primary})"/>`;
    } else if (fillAmount >= 1) {
      stars += `<path d="${starPath}" fill="${C.primary}" stroke="oklch(0.65 0.14 75)" stroke-width="1"/>`;
    } else if (fillAmount > 0) {
      stars += `<path d="${starPath}" fill="${C.track}" stroke="${C.primaryDim}" stroke-width="1"/>`;
      stars += `<clipPath id="starClip${i}"><rect x="${cx-10}" y="${cy-12}" width="${20*fillAmount}" height="24"/></clipPath>`;
      stars += `<path d="${starPath}" fill="${C.primary}" clip-path="url(#starClip${i})"/>`;
    } else {
      stars += `<path d="${starPath}" fill="${C.track}" stroke="${C.border}" stroke-width="1"/>`;
    }
  }
  el.innerHTML = `<svg width="125" height="120" viewBox="0 0 120 110">
    ${stars}
    <text x="60" y="90" text-anchor="middle" fill="${overtime?C.primary:C.text}" font-size="14" font-weight="700" font-family="system-ui">${overtime?'Wrapping up...':Math.round(clamped*100)+'%'}</text>
  </svg>`;
}
function starSvgPath(cx, cy, outerR, innerR) {
  let d = '';
  for (let i = 0; i < 5; i++) {
    const outerAngle = (i * 72 - 90) * Math.PI/180;
    const innerAngle = ((i * 72 + 36) - 90) * Math.PI/180;
    d += `${i===0?'M':'L'}${cx+outerR*Math.cos(outerAngle)},${cy+outerR*Math.sin(outerAngle)} `;
    d += `L${cx+innerR*Math.cos(innerAngle)},${cy+innerR*Math.sin(innerAngle)} `;
  }
  return d + 'Z';
}

/* 16. Projector Light — overtime: beam flickers wildly, overheating */
function renderProjectorLight(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const flicker = overtime ? 0.3 + Math.random() * 0.7 : 0.7 + Math.random() * 0.3;
  const beamOpacity = (0.2 + clamped * 0.5) * flicker;
  const heatHue = overtime ? 25 + Math.random() * 20 : 75; // shifts toward red when overheating
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 120">
    <defs>
      <linearGradient id="beamGrad" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%" stop-color="oklch(0.9 0.1 ${heatHue} / ${beamOpacity})"/>
        <stop offset="100%" stop-color="oklch(0.9 0.1 ${heatHue} / 0)"/>
      </linearGradient>
    </defs>
    <polygon points="25,30 95,5 105,45 35,50" fill="url(#beamGrad)"/>
    <rect x="8" y="25" width="35" height="30" rx="4" fill="${C.trackLight}" stroke="${overtime?C.accent:C.borderLight}" stroke-width="2"/>
    <circle cx="25" cy="40" r="10" fill="${C.card}" stroke="${C.primaryDim}" stroke-width="2"/>
    <circle cx="25" cy="40" r="4" fill="oklch(0.85 0.15 ${heatHue} / ${flicker})"/>
    <circle cx="15" cy="22" r="8" fill="none" stroke="${C.borderLight}" stroke-width="2"/>
    <circle cx="35" cy="22" r="8" fill="none" stroke="${C.borderLight}" stroke-width="2"/>
    <rect x="10" y="100" width="100" height="8" rx="4" fill="${C.track}"/>
    <rect x="10" y="100" width="100" height="8" rx="4" fill="${overtime?C.accent:C.primary}"/>
    <text x="60" y="85" text-anchor="middle" fill="${C.text}" font-size="16" font-weight="700" font-family="system-ui">${overtime?'100%':Math.round(clamped*100)+'%'}</text>
  </svg>`;
}

/* 17. Scene Slate — overtime: types "TAKE 2..." then "TAKE 3..." */
function renderSceneSlate(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  let displayText, takeNum;
  if (overtime) {
    const overPeriods = Math.floor((p - 1) * 5);
    takeNum = 2 + overPeriods;
    const msgs = ['STILL GOING...', 'ALMOST DONE...', 'PROCESSING...', 'HANG ON...', 'FINISHING...'];
    const msgIdx = Math.floor(Date.now() / 2000) % msgs.length;
    displayText = msgs[msgIdx];
  } else {
    takeNum = 1;
    const chars = 'GENERATING...';
    const shown = Math.floor(clamped * chars.length);
    displayText = chars.slice(0, shown) + (clamped < 1 ? '█' : '');
  }
  el.innerHTML = `<svg width="130" height="120" viewBox="0 0 120 105">
    <rect x="5" y="25" width="110" height="75" rx="4" fill="${C.surface}" stroke="${overtime?C.accent:C.borderLight}" stroke-width="2"/>
    <rect x="5" y="10" width="110" height="18" rx="3" fill="${C.trackLight}" stroke="${overtime?C.accent:C.borderLight}" stroke-width="1.5"/>
    ${Array.from({length:7}, (_,i) => `<rect x="${8+i*16}" y="10" width="8" height="18" fill="${i%2===0?C.bg:C.trackLight}"/>`).join('')}
    <text x="15" y="48" fill="${C.textMuted}" font-size="8" font-family="system-ui">SCENE</text>
    <text x="60" y="48" fill="${C.textMuted}" font-size="8" font-family="system-ui">TAKE</text>
    <text x="15" y="60" fill="${C.text}" font-size="11" font-weight="700" font-family="system-ui">100%</text>
    <text x="60" y="60" fill="${overtime?C.accent:C.text}" font-size="11" font-weight="700" font-family="system-ui">${takeNum}</text>
    <text x="15" y="82" fill="${C.primary}" font-size="10" font-weight="600" font-family="monospace">${displayText}</text>
    <rect x="10" y="90" width="100" height="4" rx="2" fill="${C.track}"/>
    <rect x="10" y="90" width="100" height="4" rx="2" fill="${overtime?C.accent:C.primary}"/>
  </svg>`;
}

/* 18. Reel-to-Reel Tape — overtime: left reel empty, tape flaps loose */
function renderReelToReel(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const leftR = Math.max(5, 20 - 12 * clamped); // shrinks to minimum
  const rightR = 8 + 12 * clamped;
  const rotSpeed = overtime ? 3 : 10; // spins faster in overtime
  const rot = (Date.now() / rotSpeed) % 360;
  // In overtime, tape end flaps
  const flapAngle = overtime ? Math.sin(Date.now() / 80) * 15 : 0;
  const leftSpokes = Array.from({length:3}, (_,i) => {
    const a = (rot + i*120)*Math.PI/180;
    return `<line x1="30" y1="45" x2="${30+leftR*Math.cos(a)}" y2="${45+leftR*Math.sin(a)}" stroke="${C.primaryDim}" stroke-width="2"/>`;
  }).join('');
  const rightSpokes = Array.from({length:3}, (_,i) => {
    const a = (-rot + i*120)*Math.PI/180;
    return `<line x1="90" y1="45" x2="${90+rightR*Math.cos(a)}" y2="${45+rightR*Math.sin(a)}" stroke="${C.primaryDim}" stroke-width="2"/>`;
  }).join('');
  // Flapping tape end on left reel
  const flapTape = overtime
    ? `<line x1="30" y1="45" x2="${30+leftR+8}" y2="${45+flapAngle}" stroke="${C.primary}" stroke-width="2" stroke-linecap="round"/>`
    : '';
  el.innerHTML = `<svg width="130" height="120" viewBox="0 0 120 100">
    <rect x="5" y="15" width="110" height="65" rx="6" fill="${C.surface}" stroke="${overtime?C.accent:C.borderLight}" stroke-width="2"/>
    <circle cx="30" cy="45" r="${leftR}" fill="${C.bg}" stroke="${overtime?C.accent:C.primaryDim}" stroke-width="2.5"/>
    <circle cx="30" cy="45" r="5" fill="${C.borderLight}"/>
    ${leftSpokes}
    ${flapTape}
    <circle cx="90" cy="45" r="${rightR}" fill="${C.bg}" stroke="${C.primaryDim}" stroke-width="2.5"/>
    <circle cx="90" cy="45" r="5" fill="${C.borderLight}"/>
    ${rightSpokes}
    <path d="M${30+leftR},45 Q60,25 ${90-rightR},45" fill="none" stroke="${C.primaryDim}" stroke-width="1.5"/>
    <rect x="55" y="36" width="10" height="18" rx="2" fill="${C.primary}"/>
    <text x="60" y="93" text-anchor="middle" fill="${overtime?C.accent:C.text}" font-size="12" font-weight="700" font-family="system-ui">${overtime?'Tape ran out!':Math.round(clamped*100)+'%'}</text>
  </svg>`;
}

/* 19. Marquee Lights — overtime: all lights chase faster, colors shift */
function renderMarqueeLights(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const totalLights = 20;
  const litCount = Math.floor(clamped * totalLights);
  const speed = overtime ? 100 : 300;
  const t = Date.now() / speed;
  let lights = '';

  function getLightFill(on, chaseVal) {
    if (!on) return C.track;
    if (overtime) {
      // Faster chase, alternating amber/teal
      return chaseVal > 0.3 ? C.primary : chaseVal > -0.3 ? C.accent : C.primaryGlow;
    }
    return chaseVal > 0 ? C.primary : C.accent;
  }

  for (let i = 0; i < 8; i++) {
    const on = overtime || i < Math.floor(litCount * 8/20);
    lights += `<circle cx="${16+i*13}" cy="12" r="4" fill="${getLightFill(on, Math.sin(t + i * 0.5))}"/>`;
  }
  for (let i = 0; i < 8; i++) {
    const on = overtime || (8+i) < litCount;
    lights += `<circle cx="${16+i*13}" cy="98" r="4" fill="${getLightFill(on, Math.sin(t + i * 0.5 + 2))}"/>`;
  }
  for (let i = 0; i < 2; i++) {
    const on = overtime || (16+i) < litCount;
    lights += `<circle cx="8" cy="${35+i*30}" r="4" fill="${getLightFill(on, Math.sin(t + i * 0.5 + 4))}"/>`;
    const on2 = overtime || (18+i) < litCount;
    lights += `<circle cx="112" cy="${35+i*30}" r="4" fill="${getLightFill(on2, Math.sin(t + i*0.5 + 6))}"/>`;
  }
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 110">
    <rect x="4" y="4" width="112" height="102" rx="8" fill="none" stroke="${overtime?C.primary:C.borderLight}" stroke-width="2"/>
    ${lights}
    <text x="60" y="62" text-anchor="middle" fill="${C.text}" font-size="${overtime?18:24}" font-weight="800" font-family="system-ui">${overtime?'ENCORE!':'100%'}</text>
  </svg>`;
}

/* 20. Golden Spiral — overtime: spiral keeps unwinding, rotates slowly */
function renderGoldenSpiral(el, p) {
  const overtime = p > 1;
  const clamped = Math.min(1, p);
  const phi = 1.618;
  const steps = 80;
  const maxAngle = clamped * 6 * Math.PI;
  const rotation = overtime ? (Date.now() / 50) % 360 : 0;
  let pathD = '';
  for (let i = 0; i <= steps; i++) {
    const t = (i / steps) * maxAngle;
    const r = 2 * Math.pow(phi, t / (Math.PI * 2));
    if (r > 55) break;
    const x = 60 + r * Math.cos(t);
    const y = 60 + r * Math.sin(t);
    pathD += `${i === 0 ? 'M' : 'L'}${x.toFixed(1)},${y.toFixed(1)} `;
  }
  const glowSize = overtime ? 3 + Math.sin(Date.now()/200) * 3 : 3;
  el.innerHTML = `<svg width="120" height="120" viewBox="0 0 120 120">
    <circle cx="60" cy="60" r="55" fill="none" stroke="${C.track}" stroke-width="1"/>
    <g transform="rotate(${rotation} 60 60)">
      <path d="${pathD}" fill="none" stroke="${overtime?C.accent:C.primary}" stroke-width="2.5" stroke-linecap="round"
        style="filter:drop-shadow(0 0 ${glowSize}px ${overtime?C.accent:C.primary})"/>
    </g>
    <circle cx="60" cy="60" r="3" fill="${C.primaryGlow}"/>
    <text x="60" y="115" text-anchor="middle" fill="${overtime?C.accent:C.text}" font-size="12" font-weight="700" font-family="system-ui">${overtime?'Expanding...':Math.round(clamped*100)+'%'}</text>
  </svg>`;
}

// ─── Animation loop ───
// Runs indefinitely past 100% to demonstrate overtime behavior
function tick() {
  if (!state.running || !state.startTime) {
    state.animFrameId = requestAnimationFrame(tick);
    return;
  }
  const elapsed = (Date.now() - state.startTime) / 1000;
  const p = elapsed / state.duration; // NO CLAMP — let it exceed 1.0

  for (let i = 0; i < SPINNER_COUNT; i++) {
    renderSpinner(i, p);
    const remaining = state.duration - elapsed;
    const timeEl = document.getElementById(`time-${i}`);
    if (timeEl) {
      if (remaining > 0) {
        const mins = Math.floor(remaining / 60);
        const secs = Math.floor(remaining % 60);
        timeEl.textContent = `${mins}:${secs.toString().padStart(2,'0')}`;
        timeEl.style.color = '';
      } else {
        // Overtime — show how far over we are
        const over = Math.abs(remaining);
        const oMins = Math.floor(over / 60);
        const oSecs = Math.floor(over % 60);
        timeEl.textContent = `+${oMins}:${oSecs.toString().padStart(2,'0')} over`;
        timeEl.style.color = 'oklch(0.65 0.12 195)'; // teal accent
      }
    }
  }

  // Don't auto-stop — let it run into overtime. User clicks "Reset All" to stop.
  state.animFrameId = requestAnimationFrame(tick);
}
state.animFrameId = requestAnimationFrame(tick);

// ─── Controls ───
function startAll() {
  state.duration = parseInt(document.getElementById('globalTime').value) || 15;
  state.model = document.getElementById('globalModel').value || 'flux-1.1-pro';
  state.startTime = Date.now();
  state.running = true;
  for (let i = 0; i < SPINNER_COUNT; i++) {
    const modelEl = document.getElementById(`model-${i}`);
    if (modelEl) modelEl.textContent = state.model;
  }
  updatePrompt();
}

function resetAll() {
  state.running = false;
  state.startTime = null;
  for (let i = 0; i < SPINNER_COUNT; i++) {
    renderSpinner(i, 0);
    const timeEl = document.getElementById(`time-${i}`);
    if (timeEl) timeEl.textContent = '0:00';
  }
}

// Initialize all at 0
for (let i = 0; i < SPINNER_COUNT; i++) renderSpinner(i, 0);

// ─── Prompt output ───
function updatePrompt() {
  const el = document.getElementById('promptOutput');
  const parts = [];
  if (state.selected !== null) {
    parts.push(`Use spinner variant #${state.selected + 1} "${spinnerNames[state.selected]}" as the loading indicator.`);
  }
  if (state.duration !== 15) {
    parts.push(`Default estimated time: ${state.duration} seconds.`);
  }
  if (state.model !== 'flux-1.1-pro') {
    parts.push(`Display model name: "${state.model}".`);
  }
  parts.push('Show progress percentage, estimated time remaining, and model name during generation.');
  parts.push('Use Electric Amber dark theme with OKLCH colors: primary oklch(0.75 0.16 75), backgrounds hue 250, text hue 80.');
  el.textContent = parts.length > 0 ? parts.join('\n') : 'Click a spinner card to select it, then copy this prompt.';
}

function copyPrompt() {
  const text = document.getElementById('promptOutput').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.querySelector('.copy-btn');
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy', 1500);
  });
}

updatePrompt();
</script>
</body>
</html>