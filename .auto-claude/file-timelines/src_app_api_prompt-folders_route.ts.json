{
  "file_path": "src/app/api/prompt-folders/route.ts",
  "main_branch_history": [],
  "task_views": {
    "014-user-prompts-organization-system": {
      "task_id": "014-user-prompts-organization-system",
      "branch_point": {
        "commit_hash": "8654231a22984c33942f63d8839bdca5b0d017c2",
        "content": "",
        "timestamp": "2025-12-25T18:57:09.097761"
      },
      "worktree_state": {
        "content": "import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthenticatedUser } from '@/lib/auth/api-auth'\nimport {\n  rowToPromptFolder,\n  MAX_FOLDER_NAME_LENGTH,\n  MAX_FOLDER_DESCRIPTION_LENGTH,\n  FOLDER_COLORS,\n} from '@/types/prompts'\nimport type { PromptFolderRow, FolderColor } from '@/types/prompts'\n\n// Type assertion helper for tables not yet in generated types\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype SupabaseClient = any\n\n/**\n * Validate folder color value\n */\nfunction isValidFolderColor(color: string): color is FolderColor {\n  return FOLDER_COLORS.some((c) => c.value === color)\n}\n\n/**\n * Validate UUID format\n */\nfunction isValidUuid(str: string): boolean {\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n  return uuidRegex.test(str)\n}\n\n/**\n * GET /api/prompt-folders\n * List user's folders\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { searchParams } = new URL(request.url)\n\n    // Optional search query\n    const search = searchParams.get('search')\n\n    // Build query - RLS handles user_id filtering\n    let query = client\n      .from('prompt_folders')\n      .select('*', { count: 'exact' })\n\n    // Search by name\n    if (search) {\n      const searchTerm = search.trim()\n      if (searchTerm) {\n        query = query.ilike('name', `%${searchTerm}%`)\n      }\n    }\n\n    // Sort by name alphabetically\n    query = query.order('name', { ascending: true })\n\n    const { data, error, count } = await query\n\n    if (error) {\n      console.error('Error fetching folders:', error)\n      return NextResponse.json(\n        { error: 'Failed to fetch folders' },\n        { status: 500 }\n      )\n    }\n\n    // Transform to camelCase\n    const folders = (data || []).map((row: PromptFolderRow) => rowToPromptFolder(row))\n\n    return NextResponse.json({\n      folders,\n      total: count || 0,\n    })\n  } catch (error) {\n    console.error('Prompt folders GET error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * POST /api/prompt-folders\n * Create a new folder\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { user, supabase } = auth\n    const client = supabase as SupabaseClient\n    const body = await request.json()\n\n    // Validate required fields\n    if (!body.name || typeof body.name !== 'string') {\n      return NextResponse.json(\n        { error: 'Missing required field: name' },\n        { status: 400 }\n      )\n    }\n\n    const name = body.name.trim()\n\n    // Validate name is not empty after trimming\n    if (!name) {\n      return NextResponse.json(\n        { error: 'Folder name cannot be empty' },\n        { status: 400 }\n      )\n    }\n\n    // Validate field lengths\n    if (name.length > MAX_FOLDER_NAME_LENGTH) {\n      return NextResponse.json(\n        { error: `Folder name must be ${MAX_FOLDER_NAME_LENGTH} characters or less` },\n        { status: 400 }\n      )\n    }\n\n    if (body.description && body.description.length > MAX_FOLDER_DESCRIPTION_LENGTH) {\n      return NextResponse.json(\n        { error: `Description must be ${MAX_FOLDER_DESCRIPTION_LENGTH} characters or less` },\n        { status: 400 }\n      )\n    }\n\n    // Validate color if provided\n    if (body.color && !isValidFolderColor(body.color)) {\n      return NextResponse.json(\n        { error: 'Invalid folder color' },\n        { status: 400 }\n      )\n    }\n\n    // Check for duplicate folder name for this user\n    const { data: existingFolder } = await client\n      .from('prompt_folders')\n      .select('id')\n      .eq('name', name)\n      .single()\n\n    if (existingFolder) {\n      return NextResponse.json(\n        { error: 'A folder with this name already exists' },\n        { status: 409 }\n      )\n    }\n\n    // Insert the folder\n    const { data, error } = await client\n      .from('prompt_folders')\n      .insert({\n        user_id: user.id,\n        name: name,\n        description: body.description?.trim() || null,\n        color: body.color || null,\n      })\n      .select()\n      .single()\n\n    if (error) {\n      console.error('Error creating folder:', error)\n      return NextResponse.json(\n        { error: 'Failed to create folder' },\n        { status: 500 }\n      )\n    }\n\n    const folder = rowToPromptFolder(data as PromptFolderRow)\n\n    return NextResponse.json({\n      folder,\n      message: 'Folder created successfully',\n    })\n  } catch (error) {\n    console.error('Prompt folders POST error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * PATCH /api/prompt-folders?id={folderId}\n * Update an existing folder\n */\nexport async function PATCH(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { searchParams } = new URL(request.url)\n    const folderId = searchParams.get('id')\n\n    // Validate folder ID\n    if (!folderId) {\n      return NextResponse.json(\n        { error: 'Missing required parameter: id' },\n        { status: 400 }\n      )\n    }\n\n    if (!isValidUuid(folderId)) {\n      return NextResponse.json(\n        { error: 'Invalid folder ID format' },\n        { status: 400 }\n      )\n    }\n\n    const body = await request.json()\n\n    // Check that at least one field is being updated\n    if (!body.name && body.description === undefined && body.color === undefined) {\n      return NextResponse.json(\n        { error: 'No fields to update' },\n        { status: 400 }\n      )\n    }\n\n    // Prepare update data\n    const updateData: Record<string, unknown> = {}\n\n    // Validate and add name if provided\n    if (body.name !== undefined) {\n      if (typeof body.name !== 'string') {\n        return NextResponse.json(\n          { error: 'Name must be a string' },\n          { status: 400 }\n        )\n      }\n\n      const name = body.name.trim()\n      if (!name) {\n        return NextResponse.json(\n          { error: 'Folder name cannot be empty' },\n          { status: 400 }\n        )\n      }\n\n      if (name.length > MAX_FOLDER_NAME_LENGTH) {\n        return NextResponse.json(\n          { error: `Folder name must be ${MAX_FOLDER_NAME_LENGTH} characters or less` },\n          { status: 400 }\n        )\n      }\n\n      // Check for duplicate folder name (excluding current folder)\n      const { data: existingFolder } = await client\n        .from('prompt_folders')\n        .select('id')\n        .eq('name', name)\n        .neq('id', folderId)\n        .single()\n\n      if (existingFolder) {\n        return NextResponse.json(\n          { error: 'A folder with this name already exists' },\n          { status: 409 }\n        )\n      }\n\n      updateData.name = name\n    }\n\n    // Validate and add description if provided\n    if (body.description !== undefined) {\n      if (body.description !== null && typeof body.description !== 'string') {\n        return NextResponse.json(\n          { error: 'Description must be a string or null' },\n          { status: 400 }\n        )\n      }\n\n      if (body.description && body.description.length > MAX_FOLDER_DESCRIPTION_LENGTH) {\n        return NextResponse.json(\n          { error: `Description must be ${MAX_FOLDER_DESCRIPTION_LENGTH} characters or less` },\n          { status: 400 }\n        )\n      }\n\n      updateData.description = body.description?.trim() || null\n    }\n\n    // Validate and add color if provided\n    if (body.color !== undefined) {\n      if (body.color !== null && !isValidFolderColor(body.color)) {\n        return NextResponse.json(\n          { error: 'Invalid folder color' },\n          { status: 400 }\n        )\n      }\n\n      updateData.color = body.color || null\n    }\n\n    // Add updated_at timestamp\n    updateData.updated_at = new Date().toISOString()\n\n    // Update the folder - RLS ensures user owns the folder\n    const { data, error } = await client\n      .from('prompt_folders')\n      .update(updateData)\n      .eq('id', folderId)\n      .select()\n      .single()\n\n    if (error) {\n      // Handle case where folder doesn't exist or user doesn't own it\n      if (error.code === 'PGRST116') {\n        return NextResponse.json(\n          { error: 'Folder not found' },\n          { status: 404 }\n        )\n      }\n      console.error('Error updating folder:', error)\n      return NextResponse.json(\n        { error: 'Failed to update folder' },\n        { status: 500 }\n      )\n    }\n\n    if (!data) {\n      return NextResponse.json(\n        { error: 'Folder not found' },\n        { status: 404 }\n      )\n    }\n\n    const folder = rowToPromptFolder(data as PromptFolderRow)\n\n    return NextResponse.json({\n      folder,\n      message: 'Folder updated successfully',\n    })\n  } catch (error) {\n    console.error('Prompt folders PATCH error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * DELETE /api/prompt-folders?id={folderId}\n * Delete a folder (prompts in folder will have folder_id set to null)\n */\nexport async function DELETE(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { searchParams } = new URL(request.url)\n    const folderId = searchParams.get('id')\n\n    // Validate folder ID\n    if (!folderId) {\n      return NextResponse.json(\n        { error: 'Missing required parameter: id' },\n        { status: 400 }\n      )\n    }\n\n    if (!isValidUuid(folderId)) {\n      return NextResponse.json(\n        { error: 'Invalid folder ID format' },\n        { status: 400 }\n      )\n    }\n\n    // Check if folder exists first - RLS ensures user owns it\n    const { data: existingFolder, error: checkError } = await client\n      .from('prompt_folders')\n      .select('id')\n      .eq('id', folderId)\n      .single()\n\n    if (checkError || !existingFolder) {\n      return NextResponse.json(\n        { error: 'Folder not found' },\n        { status: 404 }\n      )\n    }\n\n    // Delete the folder - prompts will have folder_id set to null via ON DELETE SET NULL\n    const { error } = await client\n      .from('prompt_folders')\n      .delete()\n      .eq('id', folderId)\n\n    if (error) {\n      console.error('Error deleting folder:', error)\n      return NextResponse.json(\n        { error: 'Failed to delete folder' },\n        { status: 500 }\n      )\n    }\n\n    return NextResponse.json({\n      message: 'Folder deleted successfully',\n    })\n  } catch (error) {\n    console.error('Prompt folders DELETE error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n",
        "last_modified": "2025-12-25T18:57:09.357510"
      },
      "task_intent": {
        "title": "014-user-prompts-organization-system",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T18:55:50.044540",
  "last_updated": "2025-12-25T18:57:09.124150"
}