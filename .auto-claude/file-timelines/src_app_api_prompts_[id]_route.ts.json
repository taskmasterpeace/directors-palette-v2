{
  "file_path": "src/app/api/prompts/[id]/route.ts",
  "main_branch_history": [],
  "task_views": {
    "014-user-prompts-organization-system": {
      "task_id": "014-user-prompts-organization-system",
      "branch_point": {
        "commit_hash": "8654231a22984c33942f63d8839bdca5b0d017c2",
        "content": "",
        "timestamp": "2025-12-25T18:57:09.097761"
      },
      "worktree_state": {
        "content": "import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthenticatedUser } from '@/lib/auth/api-auth'\nimport {\n  rowToUserPrompt,\n  normalizeTag,\n  isValidTag,\n  MAX_PROMPT_NAME_LENGTH,\n  MAX_PROMPT_DESCRIPTION_LENGTH,\n  MAX_PROMPT_CONTENT_LENGTH,\n  MAX_TAGS_PER_PROMPT,\n} from '@/types/prompts'\nimport type { UserPromptRow } from '@/types/prompts'\n\n// Type assertion helper for tables not yet in generated types\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype SupabaseClient = any\n\ninterface RouteParams {\n  params: Promise<{ id: string }>\n}\n\n/**\n * GET /api/prompts/[id]\n * Get a single prompt by ID\n */\nexport async function GET(request: NextRequest, { params }: RouteParams) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { id } = await params\n\n    // Validate UUID format\n    if (!id || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {\n      return NextResponse.json(\n        { error: 'Invalid prompt ID format' },\n        { status: 400 }\n      )\n    }\n\n    // Fetch the prompt - RLS ensures only user's own prompts are accessible\n    const { data, error } = await client\n      .from('user_prompts')\n      .select('*')\n      .eq('id', id)\n      .single()\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return NextResponse.json(\n          { error: 'Prompt not found' },\n          { status: 404 }\n        )\n      }\n      console.error('Error fetching prompt:', error)\n      return NextResponse.json(\n        { error: 'Failed to fetch prompt' },\n        { status: 500 }\n      )\n    }\n\n    const prompt = rowToUserPrompt(data as UserPromptRow)\n\n    return NextResponse.json({ prompt })\n  } catch (error) {\n    console.error('Prompt GET error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * PATCH /api/prompts/[id]\n * Update a prompt\n */\nexport async function PATCH(request: NextRequest, { params }: RouteParams) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { id } = await params\n    const body = await request.json()\n\n    // Validate UUID format\n    if (!id || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {\n      return NextResponse.json(\n        { error: 'Invalid prompt ID format' },\n        { status: 400 }\n      )\n    }\n\n    // Check if prompt exists - RLS handles user access\n    const { data: existingPrompt, error: fetchError } = await client\n      .from('user_prompts')\n      .select('id')\n      .eq('id', id)\n      .single()\n\n    if (fetchError || !existingPrompt) {\n      return NextResponse.json(\n        { error: 'Prompt not found' },\n        { status: 404 }\n      )\n    }\n\n    // Build update object with only provided fields\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const updateData: Record<string, any> = {}\n\n    // Validate and set name if provided\n    if (body.name !== undefined) {\n      if (!body.name || typeof body.name !== 'string') {\n        return NextResponse.json(\n          { error: 'Name must be a non-empty string' },\n          { status: 400 }\n        )\n      }\n      if (body.name.length > MAX_PROMPT_NAME_LENGTH) {\n        return NextResponse.json(\n          { error: `Name must be ${MAX_PROMPT_NAME_LENGTH} characters or less` },\n          { status: 400 }\n        )\n      }\n      updateData.name = body.name.trim()\n    }\n\n    // Validate and set description if provided\n    if (body.description !== undefined) {\n      if (body.description !== null && typeof body.description !== 'string') {\n        return NextResponse.json(\n          { error: 'Description must be a string or null' },\n          { status: 400 }\n        )\n      }\n      if (body.description && body.description.length > MAX_PROMPT_DESCRIPTION_LENGTH) {\n        return NextResponse.json(\n          { error: `Description must be ${MAX_PROMPT_DESCRIPTION_LENGTH} characters or less` },\n          { status: 400 }\n        )\n      }\n      updateData.description = body.description?.trim() || null\n    }\n\n    // Validate and set promptContent if provided\n    if (body.promptContent !== undefined) {\n      if (!body.promptContent || typeof body.promptContent !== 'string') {\n        return NextResponse.json(\n          { error: 'Prompt content must be a non-empty string' },\n          { status: 400 }\n        )\n      }\n      if (body.promptContent.length > MAX_PROMPT_CONTENT_LENGTH) {\n        return NextResponse.json(\n          { error: `Prompt content must be ${MAX_PROMPT_CONTENT_LENGTH} characters or less` },\n          { status: 400 }\n        )\n      }\n      updateData.prompt_content = body.promptContent\n    }\n\n    // Validate and set folderId if provided\n    if (body.folderId !== undefined) {\n      if (body.folderId !== null) {\n        // Validate folder exists and belongs to user\n        const { data: folder, error: folderError } = await client\n          .from('prompt_folders')\n          .select('id')\n          .eq('id', body.folderId)\n          .single()\n\n        if (folderError || !folder) {\n          return NextResponse.json(\n            { error: 'Folder not found' },\n            { status: 400 }\n          )\n        }\n      }\n      updateData.folder_id = body.folderId\n    }\n\n    // Validate and set tags if provided\n    if (body.tags !== undefined) {\n      if (!Array.isArray(body.tags)) {\n        return NextResponse.json(\n          { error: 'Tags must be an array' },\n          { status: 400 }\n        )\n      }\n\n      if (body.tags.length > MAX_TAGS_PER_PROMPT) {\n        return NextResponse.json(\n          { error: `Maximum ${MAX_TAGS_PER_PROMPT} tags allowed` },\n          { status: 400 }\n        )\n      }\n\n      // Normalize and validate each tag\n      const invalidTags: string[] = []\n      const normalizedTags = body.tags\n        .map((tag: string) => normalizeTag(tag))\n        .filter((tag: string) => {\n          if (!tag) return false\n          if (!isValidTag(tag)) {\n            invalidTags.push(tag)\n            return false\n          }\n          return true\n        })\n        // Remove duplicates\n        .filter((tag: string, index: number, arr: string[]) => arr.indexOf(tag) === index)\n\n      if (invalidTags.length > 0) {\n        return NextResponse.json(\n          { error: `Invalid tags: ${invalidTags.join(', ')}` },\n          { status: 400 }\n        )\n      }\n\n      updateData.tags = normalizedTags\n    }\n\n    // Check if there's anything to update\n    if (Object.keys(updateData).length === 0) {\n      return NextResponse.json(\n        { error: 'No valid fields to update' },\n        { status: 400 }\n      )\n    }\n\n    // Add updated_at timestamp\n    updateData.updated_at = new Date().toISOString()\n\n    // Perform the update\n    const { data, error } = await client\n      .from('user_prompts')\n      .update(updateData)\n      .eq('id', id)\n      .select()\n      .single()\n\n    if (error) {\n      console.error('Error updating prompt:', error)\n      return NextResponse.json(\n        { error: 'Failed to update prompt' },\n        { status: 500 }\n      )\n    }\n\n    const prompt = rowToUserPrompt(data as UserPromptRow)\n\n    return NextResponse.json({\n      prompt,\n      message: 'Prompt updated successfully',\n    })\n  } catch (error) {\n    console.error('Prompt PATCH error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * DELETE /api/prompts/[id]\n * Delete a prompt\n */\nexport async function DELETE(request: NextRequest, { params }: RouteParams) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { id } = await params\n\n    // Validate UUID format\n    if (!id || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {\n      return NextResponse.json(\n        { error: 'Invalid prompt ID format' },\n        { status: 400 }\n      )\n    }\n\n    // Check if prompt exists - RLS handles user access\n    const { data: existingPrompt, error: fetchError } = await client\n      .from('user_prompts')\n      .select('id')\n      .eq('id', id)\n      .single()\n\n    if (fetchError || !existingPrompt) {\n      return NextResponse.json(\n        { error: 'Prompt not found' },\n        { status: 404 }\n      )\n    }\n\n    // Delete the prompt\n    const { error } = await client\n      .from('user_prompts')\n      .delete()\n      .eq('id', id)\n\n    if (error) {\n      console.error('Error deleting prompt:', error)\n      return NextResponse.json(\n        { error: 'Failed to delete prompt' },\n        { status: 500 }\n      )\n    }\n\n    return NextResponse.json({\n      message: 'Prompt deleted successfully',\n    })\n  } catch (error) {\n    console.error('Prompt DELETE error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n",
        "last_modified": "2025-12-25T18:57:09.359009"
      },
      "task_intent": {
        "title": "014-user-prompts-organization-system",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T18:55:50.092829",
  "last_updated": "2025-12-25T18:57:09.173295"
}