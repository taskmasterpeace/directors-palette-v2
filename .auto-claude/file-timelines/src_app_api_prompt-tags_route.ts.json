{
  "file_path": "src/app/api/prompt-tags/route.ts",
  "main_branch_history": [],
  "task_views": {
    "014-user-prompts-organization-system": {
      "task_id": "014-user-prompts-organization-system",
      "branch_point": {
        "commit_hash": "8654231a22984c33942f63d8839bdca5b0d017c2",
        "content": "",
        "timestamp": "2025-12-25T18:57:09.097761"
      },
      "worktree_state": {
        "content": "import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthenticatedUser } from '@/lib/auth/api-auth'\nimport { rowToPromptTag, MAX_TAG_LENGTH, normalizeTag, isValidTag } from '@/types/prompts'\nimport type { PromptTagRow } from '@/types/prompts'\n\n// Type assertion helper for tables not yet in generated types\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype SupabaseClient = any\n\n/**\n * GET /api/prompt-tags\n * List user's tags for autocomplete and filtering\n *\n * Query params:\n * - search: Optional search string to filter tags (for autocomplete)\n * - limit: Optional limit on number of results (default: 50)\n * - sortBy: Optional sort field - 'usage' (default) or 'name'\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { searchParams } = new URL(request.url)\n\n    // Parse query params\n    const search = searchParams.get('search')\n    const limitParam = searchParams.get('limit')\n    const sortBy = searchParams.get('sortBy') || 'usage'\n\n    // Validate and set limit (max 100)\n    let limit = 50\n    if (limitParam) {\n      const parsedLimit = parseInt(limitParam, 10)\n      if (!isNaN(parsedLimit) && parsedLimit > 0) {\n        limit = Math.min(parsedLimit, 100)\n      }\n    }\n\n    // Build query - RLS handles user_id filtering\n    let query = client\n      .from('prompt_tags')\n      .select('*', { count: 'exact' })\n\n    // Search by tag name (for autocomplete)\n    if (search) {\n      const searchTerm = normalizeTag(search)\n      if (searchTerm) {\n        query = query.ilike('tag_name', `%${searchTerm}%`)\n      }\n    }\n\n    // Sort by usage count (most used first) or alphabetically\n    if (sortBy === 'name') {\n      query = query.order('tag_name', { ascending: true })\n    } else {\n      // Default: sort by usage_count descending, then by name\n      query = query\n        .order('usage_count', { ascending: false })\n        .order('tag_name', { ascending: true })\n    }\n\n    // Apply limit\n    query = query.limit(limit)\n\n    const { data, error, count } = await query\n\n    if (error) {\n      console.error('Error fetching tags:', error)\n      return NextResponse.json(\n        { error: 'Failed to fetch tags' },\n        { status: 500 }\n      )\n    }\n\n    // Transform to camelCase\n    const tags = (data || []).map((row: PromptTagRow) => rowToPromptTag(row))\n\n    return NextResponse.json({\n      tags,\n      total: count || 0,\n    })\n  } catch (error) {\n    console.error('Prompt tags GET error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * POST /api/prompt-tags\n * Create a new tag manually (usually tags are auto-created when added to prompts)\n * This endpoint is for pre-creating tags before using them\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { user, supabase } = auth\n    const client = supabase as SupabaseClient\n    const body = await request.json()\n\n    // Validate required fields\n    if (!body.tagName || typeof body.tagName !== 'string') {\n      return NextResponse.json(\n        { error: 'Missing required field: tagName' },\n        { status: 400 }\n      )\n    }\n\n    const tagName = normalizeTag(body.tagName)\n\n    // Validate tag is not empty after normalization\n    if (!tagName) {\n      return NextResponse.json(\n        { error: 'Tag name cannot be empty' },\n        { status: 400 }\n      )\n    }\n\n    // Validate tag format\n    if (!isValidTag(tagName)) {\n      return NextResponse.json(\n        { error: `Tag must be ${MAX_TAG_LENGTH} characters or less and not contain < or >` },\n        { status: 400 }\n      )\n    }\n\n    // Check if tag already exists for this user\n    const { data: existingTag } = await client\n      .from('prompt_tags')\n      .select('id, tag_name, usage_count')\n      .eq('tag_name', tagName)\n      .single()\n\n    if (existingTag) {\n      // Return existing tag instead of error - idempotent operation\n      const tag = rowToPromptTag(existingTag as PromptTagRow)\n      return NextResponse.json({\n        tag,\n        message: 'Tag already exists',\n      })\n    }\n\n    // Insert the tag with initial usage count of 0 (since no prompts use it yet)\n    const { data, error } = await client\n      .from('prompt_tags')\n      .insert({\n        user_id: user.id,\n        tag_name: tagName,\n        usage_count: 0,\n      })\n      .select()\n      .single()\n\n    if (error) {\n      // Handle unique constraint violation (race condition)\n      if (error.code === '23505') {\n        // Fetch the existing tag\n        const { data: existing } = await client\n          .from('prompt_tags')\n          .select('*')\n          .eq('tag_name', tagName)\n          .single()\n\n        if (existing) {\n          const tag = rowToPromptTag(existing as PromptTagRow)\n          return NextResponse.json({\n            tag,\n            message: 'Tag already exists',\n          })\n        }\n      }\n\n      console.error('Error creating tag:', error)\n      return NextResponse.json(\n        { error: 'Failed to create tag' },\n        { status: 500 }\n      )\n    }\n\n    const tag = rowToPromptTag(data as PromptTagRow)\n\n    return NextResponse.json({\n      tag,\n      message: 'Tag created successfully',\n    })\n  } catch (error) {\n    console.error('Prompt tags POST error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * DELETE /api/prompt-tags?id={tagId}\n * Delete a tag (removes it from autocomplete but doesn't affect prompts)\n * Note: If the tag is used by any prompts, it will be re-created by the sync trigger\n */\nexport async function DELETE(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { searchParams } = new URL(request.url)\n    const tagId = searchParams.get('id')\n\n    // Validate tag ID\n    if (!tagId) {\n      return NextResponse.json(\n        { error: 'Missing required parameter: id' },\n        { status: 400 }\n      )\n    }\n\n    // Validate UUID format\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n    if (!uuidRegex.test(tagId)) {\n      return NextResponse.json(\n        { error: 'Invalid tag ID format' },\n        { status: 400 }\n      )\n    }\n\n    // Check if tag exists first - RLS ensures user owns it\n    const { data: existingTag, error: checkError } = await client\n      .from('prompt_tags')\n      .select('id, usage_count')\n      .eq('id', tagId)\n      .single()\n\n    if (checkError || !existingTag) {\n      return NextResponse.json(\n        { error: 'Tag not found' },\n        { status: 404 }\n      )\n    }\n\n    // Warn if tag is in use (deletion will happen but tag may be recreated)\n    const wasInUse = existingTag.usage_count > 0\n\n    // Delete the tag\n    const { error } = await client\n      .from('prompt_tags')\n      .delete()\n      .eq('id', tagId)\n\n    if (error) {\n      console.error('Error deleting tag:', error)\n      return NextResponse.json(\n        { error: 'Failed to delete tag' },\n        { status: 500 }\n      )\n    }\n\n    return NextResponse.json({\n      message: 'Tag deleted successfully',\n      warning: wasInUse\n        ? 'Tag was in use and may be recreated when prompts are updated'\n        : undefined,\n    })\n  } catch (error) {\n    console.error('Prompt tags DELETE error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n",
        "last_modified": "2025-12-25T18:57:09.358351"
      },
      "task_intent": {
        "title": "014-user-prompts-organization-system",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T18:55:50.069056",
  "last_updated": "2025-12-25T18:57:09.148838"
}