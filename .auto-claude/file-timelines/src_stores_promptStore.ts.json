{
  "file_path": "src/stores/promptStore.ts",
  "main_branch_history": [],
  "task_views": {
    "014-user-prompts-organization-system": {
      "task_id": "014-user-prompts-organization-system",
      "branch_point": {
        "commit_hash": "8654231a22984c33942f63d8839bdca5b0d017c2",
        "content": "",
        "timestamp": "2025-12-25T18:57:09.097761"
      },
      "worktree_state": {
        "content": "import { create } from 'zustand'\nimport { devtools } from 'zustand/middleware'\n\nimport {\n  type CreateFolderRequest,\n  type CreatePromptRequest,\n  type PromptFolder,\n  type PromptSortField,\n  type PromptStore,\n  type PromptStoreState,\n  type PromptTag,\n  type SortDirection,\n  type UpdateFolderRequest,\n  type UpdatePromptRequest,\n  type UserPrompt,\n  rowToPromptFolder,\n  rowToPromptTag,\n  rowToUserPrompt,\n} from '@/types/prompts'\n\n/**\n * Prompt Library Store\n * Manages state for user prompts, folders, tags, and filtering\n */\n\nconst initialState: PromptStoreState = {\n  prompts: [],\n  folders: [],\n  tags: [],\n  selectedFolderId: null,\n  selectedTags: [],\n  searchQuery: '',\n  sortBy: 'created_at',\n  sortDirection: 'desc',\n  isLoading: false,\n  error: null,\n}\n\n/**\n * Build query string from current filter state\n */\nfunction buildQueryParams(state: PromptStoreState): URLSearchParams {\n  const params = new URLSearchParams()\n\n  if (state.selectedFolderId) {\n    params.set('folderId', state.selectedFolderId)\n  }\n\n  if (state.selectedTags.length > 0) {\n    state.selectedTags.forEach((tag) => params.append('tag', tag))\n  }\n\n  if (state.searchQuery.trim()) {\n    params.set('search', state.searchQuery.trim())\n  }\n\n  params.set('sortBy', state.sortBy)\n  params.set('sortDirection', state.sortDirection)\n\n  return params\n}\n\nexport const usePromptStore = create<PromptStore>()(\n  devtools(\n    (set, get) => ({\n      ...initialState,\n\n      // =========================================================================\n      // PROMPT ACTIONS\n      // =========================================================================\n\n      fetchPrompts: async () => {\n        set({ isLoading: true, error: null })\n\n        try {\n          const params = buildQueryParams(get())\n          const response = await fetch(`/api/prompts?${params.toString()}`)\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to fetch prompts')\n          }\n\n          const data = await response.json()\n          const prompts: UserPrompt[] = (data.prompts || []).map(rowToUserPrompt)\n\n          set({ prompts, isLoading: false })\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to fetch prompts'\n          set({ error: message, isLoading: false })\n        }\n      },\n\n      createPrompt: async (data: CreatePromptRequest) => {\n        set({ isLoading: true, error: null })\n\n        try {\n          const response = await fetch('/api/prompts', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              name: data.name,\n              description: data.description ?? null,\n              prompt_content: data.promptContent,\n              folder_id: data.folderId ?? null,\n              tags: data.tags ?? [],\n            }),\n          })\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to create prompt')\n          }\n\n          const responseData = await response.json()\n          const newPrompt = rowToUserPrompt(responseData.prompt)\n\n          // Add new prompt to state (optimistic update already done via re-fetch or add directly)\n          set((state) => ({\n            prompts: [newPrompt, ...state.prompts],\n            isLoading: false,\n          }))\n\n          return newPrompt\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to create prompt'\n          set({ error: message, isLoading: false })\n          throw error\n        }\n      },\n\n      updatePrompt: async (id: string, data: UpdatePromptRequest) => {\n        set({ isLoading: true, error: null })\n\n        try {\n          const body: Record<string, unknown> = {}\n          if (data.name !== undefined) body.name = data.name\n          if (data.description !== undefined) body.description = data.description\n          if (data.promptContent !== undefined) body.prompt_content = data.promptContent\n          if (data.folderId !== undefined) body.folder_id = data.folderId\n          if (data.tags !== undefined) body.tags = data.tags\n\n          const response = await fetch(`/api/prompts/${id}`, {\n            method: 'PATCH',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(body),\n          })\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to update prompt')\n          }\n\n          const responseData = await response.json()\n          const updatedPrompt = rowToUserPrompt(responseData.prompt)\n\n          // Update prompt in state\n          set((state) => ({\n            prompts: state.prompts.map((p) => (p.id === id ? updatedPrompt : p)),\n            isLoading: false,\n          }))\n\n          return updatedPrompt\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to update prompt'\n          set({ error: message, isLoading: false })\n          throw error\n        }\n      },\n\n      deletePrompt: async (id: string) => {\n        set({ isLoading: true, error: null })\n\n        try {\n          const response = await fetch(`/api/prompts/${id}`, {\n            method: 'DELETE',\n          })\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to delete prompt')\n          }\n\n          // Remove prompt from state\n          set((state) => ({\n            prompts: state.prompts.filter((p) => p.id !== id),\n            isLoading: false,\n          }))\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to delete prompt'\n          set({ error: message, isLoading: false })\n          throw error\n        }\n      },\n\n      incrementUseCount: async (id: string) => {\n        try {\n          // Optimistically update the use count locally\n          set((state) => ({\n            prompts: state.prompts.map((p) =>\n              p.id === id\n                ? {\n                    ...p,\n                    useCount: p.useCount + 1,\n                    lastUsedAt: new Date().toISOString(),\n                  }\n                : p\n            ),\n          }))\n\n          // Send update to server (fire and forget, non-blocking)\n          const response = await fetch(`/api/prompts/${id}`, {\n            method: 'PATCH',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              use_count_increment: true,\n            }),\n          })\n\n          if (!response.ok) {\n            // Rollback optimistic update on failure\n            const currentPrompts = get().prompts\n            const originalPrompt = currentPrompts.find((p) => p.id === id)\n            if (originalPrompt) {\n              set((state) => ({\n                prompts: state.prompts.map((p) =>\n                  p.id === id\n                    ? {\n                        ...p,\n                        useCount: originalPrompt.useCount - 1,\n                        lastUsedAt: originalPrompt.lastUsedAt,\n                      }\n                    : p\n                ),\n              }))\n            }\n          }\n        } catch {\n          // Silent failure for use count increment - non-critical operation\n        }\n      },\n\n      // =========================================================================\n      // FOLDER ACTIONS\n      // =========================================================================\n\n      fetchFolders: async () => {\n        try {\n          const response = await fetch('/api/prompt-folders')\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to fetch folders')\n          }\n\n          const data = await response.json()\n          const folders: PromptFolder[] = (data.folders || []).map(rowToPromptFolder)\n\n          set({ folders })\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to fetch folders'\n          set({ error: message })\n        }\n      },\n\n      createFolder: async (data: CreateFolderRequest) => {\n        set({ isLoading: true, error: null })\n\n        try {\n          const response = await fetch('/api/prompt-folders', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              name: data.name,\n              description: data.description ?? null,\n              color: data.color ?? null,\n            }),\n          })\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to create folder')\n          }\n\n          const responseData = await response.json()\n          const newFolder = rowToPromptFolder(responseData.folder)\n\n          set((state) => ({\n            folders: [...state.folders, newFolder],\n            isLoading: false,\n          }))\n\n          return newFolder\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to create folder'\n          set({ error: message, isLoading: false })\n          throw error\n        }\n      },\n\n      updateFolder: async (id: string, data: UpdateFolderRequest) => {\n        set({ isLoading: true, error: null })\n\n        try {\n          const params = new URLSearchParams({ id })\n          const response = await fetch(`/api/prompt-folders?${params.toString()}`, {\n            method: 'PATCH',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              name: data.name,\n              description: data.description,\n              color: data.color,\n            }),\n          })\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to update folder')\n          }\n\n          const responseData = await response.json()\n          const updatedFolder = rowToPromptFolder(responseData.folder)\n\n          set((state) => ({\n            folders: state.folders.map((f) => (f.id === id ? updatedFolder : f)),\n            isLoading: false,\n          }))\n\n          return updatedFolder\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to update folder'\n          set({ error: message, isLoading: false })\n          throw error\n        }\n      },\n\n      deleteFolder: async (id: string) => {\n        set({ isLoading: true, error: null })\n\n        try {\n          const params = new URLSearchParams({ id })\n          const response = await fetch(`/api/prompt-folders?${params.toString()}`, {\n            method: 'DELETE',\n          })\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to delete folder')\n          }\n\n          // Remove folder from state and clear selection if it was selected\n          set((state) => ({\n            folders: state.folders.filter((f) => f.id !== id),\n            selectedFolderId: state.selectedFolderId === id ? null : state.selectedFolderId,\n            // Update prompts that were in this folder to have null folderId\n            prompts: state.prompts.map((p) => (p.folderId === id ? { ...p, folderId: null } : p)),\n            isLoading: false,\n          }))\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to delete folder'\n          set({ error: message, isLoading: false })\n          throw error\n        }\n      },\n\n      // =========================================================================\n      // TAG ACTIONS\n      // =========================================================================\n\n      fetchTags: async () => {\n        try {\n          const response = await fetch('/api/prompt-tags')\n\n          if (!response.ok) {\n            const errorData = await response.json()\n            throw new Error(errorData.error || 'Failed to fetch tags')\n          }\n\n          const data = await response.json()\n          const tags: PromptTag[] = (data.tags || []).map(rowToPromptTag)\n\n          set({ tags })\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to fetch tags'\n          set({ error: message })\n        }\n      },\n\n      // =========================================================================\n      // FILTER ACTIONS\n      // =========================================================================\n\n      setSelectedFolderId: (folderId: string | null) => {\n        set({ selectedFolderId: folderId })\n      },\n\n      setSelectedTags: (tags: string[]) => {\n        set({ selectedTags: tags })\n      },\n\n      toggleTag: (tag: string) => {\n        set((state) => {\n          const isSelected = state.selectedTags.includes(tag)\n          return {\n            selectedTags: isSelected\n              ? state.selectedTags.filter((t) => t !== tag)\n              : [...state.selectedTags, tag],\n          }\n        })\n      },\n\n      setSearchQuery: (query: string) => {\n        set({ searchQuery: query })\n      },\n\n      setSortBy: (sortBy: PromptSortField) => {\n        set({ sortBy })\n      },\n\n      setSortDirection: (direction: SortDirection) => {\n        set({ sortDirection: direction })\n      },\n\n      clearFilters: () => {\n        set({\n          selectedFolderId: null,\n          selectedTags: [],\n          searchQuery: '',\n          sortBy: 'created_at',\n          sortDirection: 'desc',\n        })\n      },\n\n      // =========================================================================\n      // UTILITY ACTIONS\n      // =========================================================================\n\n      setError: (error: string | null) => {\n        set({ error })\n      },\n\n      reset: () => {\n        set(initialState)\n      },\n    }),\n    { name: 'prompt-store' }\n  )\n)\n\n/**\n * Selector hooks for common access patterns\n */\nexport const usePrompts = () => usePromptStore((state) => state.prompts)\nexport const useFolders = () => usePromptStore((state) => state.folders)\nexport const useTags = () => usePromptStore((state) => state.tags)\nexport const usePromptFilters = () =>\n  usePromptStore((state) => ({\n    selectedFolderId: state.selectedFolderId,\n    selectedTags: state.selectedTags,\n    searchQuery: state.searchQuery,\n    sortBy: state.sortBy,\n    sortDirection: state.sortDirection,\n  }))\nexport const usePromptLoading = () => usePromptStore((state) => state.isLoading)\nexport const usePromptError = () => usePromptStore((state) => state.error)\n\n/**\n * Get a single prompt by ID\n */\nexport const usePromptById = (id: string) =>\n  usePromptStore((state) => state.prompts.find((p) => p.id === id))\n\n/**\n * Get prompts filtered by the current folder selection\n */\nexport const useFilteredPrompts = () =>\n  usePromptStore((state) => {\n    let filtered = state.prompts\n\n    // Filter by folder\n    if (state.selectedFolderId !== null) {\n      filtered = filtered.filter((p) => p.folderId === state.selectedFolderId)\n    }\n\n    // Filter by tags (prompt must have all selected tags)\n    if (state.selectedTags.length > 0) {\n      filtered = filtered.filter((p) =>\n        state.selectedTags.every((tag) => p.tags.includes(tag))\n      )\n    }\n\n    // Filter by search query (client-side filtering for immediate feedback)\n    if (state.searchQuery.trim()) {\n      const query = state.searchQuery.toLowerCase().trim()\n      filtered = filtered.filter(\n        (p) =>\n          p.name.toLowerCase().includes(query) ||\n          p.description?.toLowerCase().includes(query) ||\n          p.promptContent.toLowerCase().includes(query) ||\n          p.tags.some((tag) => tag.toLowerCase().includes(query))\n      )\n    }\n\n    return filtered\n  })\n\n/**\n * Get folder by ID\n */\nexport const useFolderById = (id: string | null) =>\n  usePromptStore((state) => (id ? state.folders.find((f) => f.id === id) : undefined))\n\n/**\n * Get prompts count by folder\n */\nexport const usePromptsCountByFolder = () =>\n  usePromptStore((state) => {\n    const counts: Record<string, number> = { root: 0 }\n\n    state.prompts.forEach((p) => {\n      if (p.folderId) {\n        counts[p.folderId] = (counts[p.folderId] || 0) + 1\n      } else {\n        counts.root += 1\n      }\n    })\n\n    return counts\n  })\n",
        "last_modified": "2025-12-25T18:57:09.360915"
      },
      "task_intent": {
        "title": "014-user-prompts-organization-system",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T18:55:50.146225",
  "last_updated": "2025-12-25T18:57:09.251388"
}