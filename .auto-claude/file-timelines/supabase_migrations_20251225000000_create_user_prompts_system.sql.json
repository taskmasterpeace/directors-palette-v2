{
  "file_path": "supabase/migrations/20251225000000_create_user_prompts_system.sql",
  "main_branch_history": [],
  "task_views": {
    "014-user-prompts-organization-system": {
      "task_id": "014-user-prompts-organization-system",
      "branch_point": {
        "commit_hash": "8654231a22984c33942f63d8839bdca5b0d017c2",
        "content": "",
        "timestamp": "2025-12-25T18:57:09.097761"
      },
      "worktree_state": {
        "content": "-- User Prompts Organization System Tables\n-- Created: 2025-12-25\n\n-- ============================================================================\n-- PROMPT FOLDERS TABLE\n-- ============================================================================\n-- Flat folder structure (single level) for organizing user prompts\nCREATE TABLE IF NOT EXISTS prompt_folders (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  name TEXT NOT NULL,\n  description TEXT,\n  color TEXT, -- Optional color for folder icon/display\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n\n  -- Unique folder name per user\n  UNIQUE(user_id, name)\n);\n\n-- Indexes for prompt_folders\nCREATE INDEX idx_prompt_folders_user ON prompt_folders(user_id);\n\n-- ============================================================================\n-- USER PROMPTS TABLE\n-- ============================================================================\n-- Main table for storing user's saved prompts\nCREATE TABLE IF NOT EXISTS user_prompts (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  folder_id UUID REFERENCES prompt_folders(id) ON DELETE SET NULL,\n  name TEXT NOT NULL,\n  description TEXT,\n  prompt_content TEXT NOT NULL,\n  tags TEXT[] DEFAULT '{}',\n\n  -- Usage tracking\n  use_count INTEGER DEFAULT 0,\n  last_used_at TIMESTAMP WITH TIME ZONE,\n\n  -- Timestamps\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Indexes for user_prompts\nCREATE INDEX idx_user_prompts_user ON user_prompts(user_id);\nCREATE INDEX idx_user_prompts_folder ON user_prompts(folder_id);\nCREATE INDEX idx_user_prompts_created_at ON user_prompts(created_at);\nCREATE INDEX idx_user_prompts_name ON user_prompts(name);\n-- GIN index for full-text search on prompt content and tags\nCREATE INDEX idx_user_prompts_tags ON user_prompts USING GIN(tags);\nCREATE INDEX idx_user_prompts_search ON user_prompts USING GIN(to_tsvector('english', name || ' ' || COALESCE(description, '') || ' ' || prompt_content));\n\n-- ============================================================================\n-- PROMPT TAGS TABLE\n-- ============================================================================\n-- Tracks unique tags per user for autocomplete functionality\nCREATE TABLE IF NOT EXISTS prompt_tags (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  tag_name TEXT NOT NULL,\n  usage_count INTEGER DEFAULT 1,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n\n  -- Unique tag per user (lowercase normalized)\n  UNIQUE(user_id, tag_name)\n);\n\n-- Indexes for prompt_tags\nCREATE INDEX idx_prompt_tags_user ON prompt_tags(user_id);\nCREATE INDEX idx_prompt_tags_name ON prompt_tags(tag_name);\nCREATE INDEX idx_prompt_tags_usage ON prompt_tags(user_id, usage_count DESC);\n\n-- ============================================================================\n-- ROW LEVEL SECURITY\n-- ============================================================================\n\n-- Enable RLS\nALTER TABLE prompt_folders ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_prompts ENABLE ROW LEVEL SECURITY;\nALTER TABLE prompt_tags ENABLE ROW LEVEL SECURITY;\n\n-- Prompt Folders Policies\nCREATE POLICY \"Users can view their own folders\"\n  ON prompt_folders FOR SELECT\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert their own folders\"\n  ON prompt_folders FOR INSERT\n  WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own folders\"\n  ON prompt_folders FOR UPDATE\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can delete their own folders\"\n  ON prompt_folders FOR DELETE\n  USING (auth.uid() = user_id);\n\n-- User Prompts Policies\nCREATE POLICY \"Users can view their own prompts\"\n  ON user_prompts FOR SELECT\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert their own prompts\"\n  ON user_prompts FOR INSERT\n  WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own prompts\"\n  ON user_prompts FOR UPDATE\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can delete their own prompts\"\n  ON user_prompts FOR DELETE\n  USING (auth.uid() = user_id);\n\n-- Prompt Tags Policies\nCREATE POLICY \"Users can view their own tags\"\n  ON prompt_tags FOR SELECT\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert their own tags\"\n  ON prompt_tags FOR INSERT\n  WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own tags\"\n  ON prompt_tags FOR UPDATE\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can delete their own tags\"\n  ON prompt_tags FOR DELETE\n  USING (auth.uid() = user_id);\n\n-- ============================================================================\n-- TRIGGERS\n-- ============================================================================\n\n-- Updated_at trigger function (reuse if exists, create if not)\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Updated_at triggers for all tables\nCREATE TRIGGER trigger_prompt_folders_updated_at\nBEFORE UPDATE ON prompt_folders\nFOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER trigger_user_prompts_updated_at\nBEFORE UPDATE ON user_prompts\nFOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER trigger_prompt_tags_updated_at\nBEFORE UPDATE ON prompt_tags\nFOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\n-- ============================================================================\n-- TAG SYNCHRONIZATION TRIGGER\n-- ============================================================================\n-- Automatically update prompt_tags table when tags are added/removed from prompts\n\nCREATE OR REPLACE FUNCTION sync_prompt_tags()\nRETURNS TRIGGER AS $$\nDECLARE\n  old_tags TEXT[];\n  new_tags TEXT[];\n  added_tags TEXT[];\n  removed_tags TEXT[];\n  tag TEXT;\nBEGIN\n  -- Get old and new tags (handle INSERT case where OLD is null)\n  IF TG_OP = 'DELETE' THEN\n    old_tags := OLD.tags;\n    new_tags := '{}';\n  ELSIF TG_OP = 'INSERT' THEN\n    old_tags := '{}';\n    new_tags := COALESCE(NEW.tags, '{}');\n  ELSE -- UPDATE\n    old_tags := COALESCE(OLD.tags, '{}');\n    new_tags := COALESCE(NEW.tags, '{}');\n  END IF;\n\n  -- Find added tags (in new but not in old)\n  SELECT ARRAY_AGG(elem) INTO added_tags\n  FROM unnest(new_tags) AS elem\n  WHERE elem NOT IN (SELECT unnest(old_tags));\n\n  -- Find removed tags (in old but not in new)\n  SELECT ARRAY_AGG(elem) INTO removed_tags\n  FROM unnest(old_tags) AS elem\n  WHERE elem NOT IN (SELECT unnest(new_tags));\n\n  -- Increment usage count for added tags\n  IF added_tags IS NOT NULL THEN\n    FOREACH tag IN ARRAY added_tags\n    LOOP\n      INSERT INTO prompt_tags (user_id, tag_name, usage_count)\n      VALUES (COALESCE(NEW.user_id, OLD.user_id), LOWER(TRIM(tag)), 1)\n      ON CONFLICT (user_id, tag_name)\n      DO UPDATE SET\n        usage_count = prompt_tags.usage_count + 1,\n        updated_at = NOW();\n    END LOOP;\n  END IF;\n\n  -- Decrement usage count for removed tags\n  IF removed_tags IS NOT NULL THEN\n    FOREACH tag IN ARRAY removed_tags\n    LOOP\n      UPDATE prompt_tags\n      SET\n        usage_count = usage_count - 1,\n        updated_at = NOW()\n      WHERE user_id = COALESCE(NEW.user_id, OLD.user_id)\n        AND tag_name = LOWER(TRIM(tag));\n\n      -- Clean up tags with zero usage\n      DELETE FROM prompt_tags\n      WHERE user_id = COALESCE(NEW.user_id, OLD.user_id)\n        AND tag_name = LOWER(TRIM(tag))\n        AND usage_count <= 0;\n    END LOOP;\n  END IF;\n\n  IF TG_OP = 'DELETE' THEN\n    RETURN OLD;\n  ELSE\n    RETURN NEW;\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_sync_prompt_tags\nAFTER INSERT OR UPDATE OR DELETE ON user_prompts\nFOR EACH ROW EXECUTE FUNCTION sync_prompt_tags();\n",
        "last_modified": "2025-12-25T18:57:09.362951"
      },
      "task_intent": {
        "title": "014-user-prompts-organization-system",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T18:55:50.239024",
  "last_updated": "2025-12-25T18:57:09.328912"
}