{
  "file_path": "src/app/api/prompts/route.ts",
  "main_branch_history": [],
  "task_views": {
    "014-user-prompts-organization-system": {
      "task_id": "014-user-prompts-organization-system",
      "branch_point": {
        "commit_hash": "8654231a22984c33942f63d8839bdca5b0d017c2",
        "content": "",
        "timestamp": "2025-12-25T18:57:09.097761"
      },
      "worktree_state": {
        "content": "import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthenticatedUser } from '@/lib/auth/api-auth'\nimport {\n  rowToUserPrompt,\n  normalizeTag,\n  isValidTag,\n  MAX_PROMPT_NAME_LENGTH,\n  MAX_PROMPT_DESCRIPTION_LENGTH,\n  MAX_PROMPT_CONTENT_LENGTH,\n  MAX_TAGS_PER_PROMPT,\n} from '@/types/prompts'\nimport type {\n  PromptSortField,\n  SortDirection,\n  UserPromptRow,\n} from '@/types/prompts'\n\n// Type assertion helper for tables not yet in generated types\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype SupabaseClient = any\n\n/**\n * GET /api/prompts\n * List user's prompts with optional filters and sorting\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { supabase } = auth\n    const client = supabase as SupabaseClient\n    const { searchParams } = new URL(request.url)\n\n    // Parse query params\n    const folderId = searchParams.get('folderId')\n    const tags = searchParams.get('tags')\n    const search = searchParams.get('search')\n    const sortBy = (searchParams.get('sortBy') || 'created_at') as PromptSortField\n    const sortDirection = (searchParams.get('sortDirection') || 'desc') as SortDirection\n    const limit = parseInt(searchParams.get('limit') || '50', 10)\n    const offset = parseInt(searchParams.get('offset') || '0', 10)\n\n    // Build query - RLS handles user_id filtering\n    let query = client\n      .from('user_prompts')\n      .select('*', { count: 'exact' })\n\n    // Filter by folder\n    if (folderId === 'null' || folderId === 'root') {\n      // Get prompts without a folder\n      query = query.is('folder_id', null)\n    } else if (folderId) {\n      query = query.eq('folder_id', folderId)\n    }\n\n    // Filter by tags (contains all specified tags)\n    if (tags) {\n      const tagList = tags.split(',').map((t) => normalizeTag(t)).filter(Boolean)\n      if (tagList.length > 0) {\n        // Use contains operator for array - prompts must have all specified tags\n        query = query.contains('tags', tagList)\n      }\n    }\n\n    // Search by name, description, or content\n    if (search) {\n      const searchTerm = search.trim()\n      if (searchTerm) {\n        query = query.or(\n          `name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%,prompt_content.ilike.%${searchTerm}%`\n        )\n      }\n    }\n\n    // Map sortBy field names to database column names\n    const sortFieldMap: Record<PromptSortField, string> = {\n      name: 'name',\n      created_at: 'created_at',\n      updated_at: 'updated_at',\n      use_count: 'use_count',\n      last_used_at: 'last_used_at',\n    }\n\n    const sortColumn = sortFieldMap[sortBy] || 'created_at'\n    const ascending = sortDirection === 'asc'\n\n    // Apply sorting\n    query = query.order(sortColumn, { ascending })\n\n    // Apply pagination\n    query = query.range(offset, offset + limit - 1)\n\n    const { data, error, count } = await query\n\n    if (error) {\n      console.error('Error fetching prompts:', error)\n      return NextResponse.json(\n        { error: 'Failed to fetch prompts' },\n        { status: 500 }\n      )\n    }\n\n    // Transform to camelCase\n    const prompts = (data || []).map((row: UserPromptRow) => rowToUserPrompt(row))\n\n    return NextResponse.json({\n      prompts,\n      total: count || 0,\n      limit,\n      offset,\n    })\n  } catch (error) {\n    console.error('Prompts GET error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * POST /api/prompts\n * Create a new prompt\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const auth = await getAuthenticatedUser(request)\n    if (auth instanceof NextResponse) return auth\n\n    const { user, supabase } = auth\n    const client = supabase as SupabaseClient\n    const body = await request.json()\n\n    // Validate required fields\n    if (!body.name || !body.promptContent) {\n      return NextResponse.json(\n        { error: 'Missing required fields: name, promptContent' },\n        { status: 400 }\n      )\n    }\n\n    // Validate field lengths\n    if (body.name.length > MAX_PROMPT_NAME_LENGTH) {\n      return NextResponse.json(\n        { error: `Name must be ${MAX_PROMPT_NAME_LENGTH} characters or less` },\n        { status: 400 }\n      )\n    }\n\n    if (body.description && body.description.length > MAX_PROMPT_DESCRIPTION_LENGTH) {\n      return NextResponse.json(\n        { error: `Description must be ${MAX_PROMPT_DESCRIPTION_LENGTH} characters or less` },\n        { status: 400 }\n      )\n    }\n\n    if (body.promptContent.length > MAX_PROMPT_CONTENT_LENGTH) {\n      return NextResponse.json(\n        { error: `Prompt content must be ${MAX_PROMPT_CONTENT_LENGTH} characters or less` },\n        { status: 400 }\n      )\n    }\n\n    // Validate and normalize tags\n    let tags: string[] = []\n    if (body.tags && Array.isArray(body.tags)) {\n      if (body.tags.length > MAX_TAGS_PER_PROMPT) {\n        return NextResponse.json(\n          { error: `Maximum ${MAX_TAGS_PER_PROMPT} tags allowed` },\n          { status: 400 }\n        )\n      }\n\n      // Normalize and validate each tag\n      const invalidTags: string[] = []\n      tags = body.tags\n        .map((tag: string) => normalizeTag(tag))\n        .filter((tag: string) => {\n          if (!isValidTag(tag)) {\n            invalidTags.push(tag)\n            return false\n          }\n          return true\n        })\n        // Remove duplicates\n        .filter((tag: string, index: number, arr: string[]) => arr.indexOf(tag) === index)\n\n      if (invalidTags.length > 0) {\n        return NextResponse.json(\n          { error: `Invalid tags: ${invalidTags.join(', ')}` },\n          { status: 400 }\n        )\n      }\n    }\n\n    // Validate folder exists if provided\n    if (body.folderId) {\n      const { data: folder, error: folderError } = await client\n        .from('prompt_folders')\n        .select('id')\n        .eq('id', body.folderId)\n        .single()\n\n      if (folderError || !folder) {\n        return NextResponse.json(\n          { error: 'Folder not found' },\n          { status: 400 }\n        )\n      }\n    }\n\n    // Insert the prompt\n    const { data, error } = await client\n      .from('user_prompts')\n      .insert({\n        user_id: user.id,\n        name: body.name.trim(),\n        description: body.description?.trim() || null,\n        prompt_content: body.promptContent,\n        folder_id: body.folderId || null,\n        tags: tags,\n      })\n      .select()\n      .single()\n\n    if (error) {\n      console.error('Error creating prompt:', error)\n      return NextResponse.json(\n        { error: 'Failed to create prompt' },\n        { status: 500 }\n      )\n    }\n\n    const prompt = rowToUserPrompt(data as UserPromptRow)\n\n    return NextResponse.json({\n      prompt,\n      message: 'Prompt created successfully',\n    })\n  } catch (error) {\n    console.error('Prompts POST error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n",
        "last_modified": "2025-12-25T18:57:09.359684"
      },
      "task_intent": {
        "title": "014-user-prompts-organization-system",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T18:55:50.119148",
  "last_updated": "2025-12-25T18:57:09.198713"
}