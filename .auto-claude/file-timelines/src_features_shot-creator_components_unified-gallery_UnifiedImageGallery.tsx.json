{
  "file_path": "src/features/shot-creator/components/unified-gallery/UnifiedImageGallery.tsx",
  "main_branch_history": [],
  "task_views": {
    "013-multi-select-gallery-with-bulk-actions": {
      "task_id": "013-multi-select-gallery-with-bulk-actions",
      "branch_point": {
        "commit_hash": "8654231a22984c33942f63d8839bdca5b0d017c2",
        "content": "'use client'\n\nimport { useEffect, useCallback, useState } from 'react'\nimport { Card, CardContent } from '@/components/ui/card'\nimport { ScrollArea } from '@/components/ui/scroll-area'\nimport { LoadingSpinner } from '@/components/ui/loading-spinner'\nimport { ImageIcon } from 'lucide-react'\nimport { cn } from '@/utils/utils'\nimport { useReferenceNamePrompt } from '@/components/providers/PromptProvider'\nimport { useIsMobile } from '@/hooks/use-mobile'\nimport { useToast } from '@/hooks/use-toast'\nimport { autoExtractFrames } from '@/features/layout-annotation/services/grid-detector'\nimport { LoadMoreButton } from './LoadMoreButton'\nimport { useGalleryLogic } from \"../../hooks/useGalleryLogic\"\nimport { ImageCard } from \"./ImageCard\"\nimport { GalleryHeader } from \"./GalleryHeader\"\nimport FullscreenModal from \"./FullScreenModal\"\nimport { FolderSidebar } from \"./FolderSidebar\"\nimport { MobileFolderMenu } from \"./MobileFolderMenu\"\nimport { FolderManagerModal } from \"./FolderManagerModal\"\nimport { BulkDownloadModal } from \"./BulkDownloadModal\"\nimport { useFolderManager } from \"../../hooks/useFolderManager\"\nimport { GeneratedImage, useUnifiedGalleryStore, GridSize } from '../../store/unified-gallery-store'\n\nexport interface UnifiedImageGalleryProps {\n    currentTab?: 'shot-creator' | 'shot-animator' | 'layout-annotation' | 'gallery' | 'story-creator'\n    mode?: 'minimal' | 'full'\n    isLoading?: boolean\n    onSendToTab?: (imageUrl: string, targetTab: string) => void\n    onUseAsReference?: (imageUrl: string) => void\n    onSendToLibrary?: (imageUrl: string, galleryId: string) => void\n    onSendToLayoutAnnotation?: (imageUrl: string) => void\n    onSendToShotAnimator?: (imageUrl: string) => void\n    onImageSelect?: (imageUrl: string) => void\n    className?: string\n}\n\nexport function UnifiedImageGallery({\n    currentTab,\n    mode = 'full',\n    isLoading = false,\n    onSendToTab,\n    onUseAsReference,\n    onSendToShotAnimator,\n    onSendToLayoutAnnotation,\n    onSendToLibrary,\n    onImageSelect,\n    className\n}: UnifiedImageGalleryProps) {\n    const {\n        images,\n        paginatedImages,\n        filters,\n        fullscreenImage,\n        totalImages,\n        totalCredits,\n        handleCopyImage,\n        handleDownloadImage,\n        handleDeleteImage,\n        handleSendTo,\n        handleSearchChange,\n        setFullscreenImage,\n        selectedImages,\n        handleSelectAll,\n        handleClearSelection,\n        handleDeleteSelected,\n        handleImageSelect,\n        updateImageReference,\n        downloadModalOpen,\n        downloadProgress,\n        handleBulkDownload,\n        setDownloadModalOpen\n    } = useGalleryLogic(onSendToTab, onUseAsReference, onSendToShotAnimator, onSendToLayoutAnnotation, onSendToLibrary, onImageSelect)\n\n    const showReferenceNamePrompt = useReferenceNamePrompt()\n    const { toast } = useToast()\n\n    // Get grid size, pagination, and database count from store\n    const gridSize = useUnifiedGalleryStore(state => state.gridSize)\n    const setGridSize = useUnifiedGalleryStore(state => state.setGridSize)\n    const totalDatabaseCount = useUnifiedGalleryStore(state => state.totalDatabaseCount)\n    const useNativeAspectRatio = useUnifiedGalleryStore(state => state.useNativeAspectRatio)\n    const setUseNativeAspectRatio = useUnifiedGalleryStore(state => state.setUseNativeAspectRatio)\n\n    // Get infinite scroll state from store\n    const hasMore = useUnifiedGalleryStore(state => state.hasMore)\n    const isLoadingMore = useUnifiedGalleryStore(state => state.isLoadingMore)\n    const loadMoreImages = useUnifiedGalleryStore(state => state.loadMoreImages)\n\n    // Folder state from store\n    const folders = useUnifiedGalleryStore(state => state.folders)\n    const currentFolderId = useUnifiedGalleryStore(state => state.currentFolderId)\n    const isFoldersLoading = useUnifiedGalleryStore(state => state.isFoldersLoading)\n    const setCurrentFolder = useUnifiedGalleryStore(state => state.setCurrentFolder)\n    const getUncategorizedCount = useUnifiedGalleryStore(state => state.getUncategorizedCount)\n\n    // Folder manager hook\n    const {\n        modalMode,\n        selectedFolder,\n        openCreateModal,\n        openEditModal,\n        openDeleteModal,\n        closeModal,\n        handleCreateFolder,\n        handleUpdateFolder,\n        handleDeleteFolder,\n        handleMoveImages,\n    } = useFolderManager()\n\n    // Mobile detection for responsive scroll behavior\n    const isMobile = useIsMobile()\n\n    // Local UI state\n    const [isMobileFolderMenuOpen, setIsMobileFolderMenuOpen] = useState(false)\n    const [removingBackgroundId, setRemovingBackgroundId] = useState<string | null>(null)\n    const [generatingCinematicId, setGeneratingCinematicId] = useState<string | null>(null)\n\n    // Handle background removal\n    const handleRemoveBackground = useCallback(async (image: GeneratedImage) => {\n        if (removingBackgroundId) return // Prevent multiple concurrent removals\n\n        setRemovingBackgroundId(image.id)\n        toast({\n            title: \"Removing Background\",\n            description: \"Processing image... (3 pts)\"\n        })\n\n        try {\n            const response = await fetch('/api/tools/remove-background', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    imageUrl: image.url,\n                    galleryId: image.id\n                })\n            })\n\n            const result = await response.json()\n\n            if (!response.ok) {\n                throw new Error(result.error || 'Failed to remove background')\n            }\n\n            toast({\n                title: \"Background Removed!\",\n                description: \"New image saved to gallery. Refreshing...\"\n            })\n\n            // Refresh gallery to show the new image\n            setTimeout(async () => {\n                await useUnifiedGalleryStore.getState().refreshGallery()\n            }, 500)\n        } catch (error) {\n            console.error('Background removal error:', error)\n            toast({\n                title: \"Remove Background Failed\",\n                description: error instanceof Error ? error.message : \"An error occurred\",\n                variant: \"destructive\"\n            })\n        } finally {\n            setRemovingBackgroundId(null)\n        }\n    }, [removingBackgroundId, toast])\n\n    // Handle 9-Shot Cinematic Grid generation\n    const handleGenerateCinematicGrid = useCallback(async (image: GeneratedImage) => {\n        if (generatingCinematicId) return // Prevent multiple concurrent generations\n\n        setGeneratingCinematicId(image.id)\n        toast({\n            title: \"Generating 9-Shot Cinematic\",\n            description: \"Creating cinematic grid... This may take a moment.\"\n        })\n\n        try {\n            // Template image for 9-shot cinematic layout\n            // Use NEXT_PUBLIC_SITE_URL for public access, fallback to production URL\n            const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://directorspalette.app'\n            const cinematicTemplateUrl = `${siteUrl}/templates/cinematic-reference.png`\n\n            // Proper cinematic grid prompt with detailed instructions\n            const cinematicPrompt = `<instruction> Analyze the entire composition of the input image. Identify all key subjects present (whether it's a single person, a group/couple, a vehicle, or a specific object) and their spatial relationship or interaction. Generate a cohesive 3x3 cinematic contact sheet featuring 9 distinct camera shots of exactly these subjects in the same environment. These shots must cover the full range from wide environmental framing to intimate close detail. Adapt the framing to fit the content: if the subject is a group, keep the group together; if the subject is an object, frame the entire object appropriately. Row 1 should consist of three progressively closer environmental/context shots, beginning with a very distant wide view, followed by a full-body view, and then a slightly tighter long-framing view. Row 2 should cover the core subject area: a waist-up framing, a chest-up framing, and a tight facial or frontal framing. Row 3 should focus on intimate details and angle variations: a macro detail shot, a dramatic low-angle upward shot, and a high-angle downward shot. Ensure strict consistency across all 9 frames: identical subjects, identical outfits, identical environment, identical lighting, and coherent scene continuity. Depth of field should become increasingly shallow as the framing moves closer, especially in the final row. </instruction> A professional 3x3 cinematic storyboard grid containing 9 panels, covering the entire visual range from wide environmental shots to macro detail. No labels, text, overlays, icons, or shot-type captions in any frame. Only clean cinematic imagery. Top row: wide environment, full-body, medium-long view. Middle row: waist-up, chest-up, tight face/front framing. Bottom row: macro detail, low-angle, high-angle. All frames must feature consistent photorealistic textures, cinematic color grading, and faithful continuity of subjects and scene. maintain the provided style`\n\n            // Send BOTH the user's selected image AND the template image\n            const response = await fetch('/api/generation/image', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    model: 'nano-banana-pro', // Use Nano Banana Pro for best quality\n                    prompt: cinematicPrompt,\n                    referenceImages: [\n                        { url: image.url, weight: 0.8 },          // User's selected image\n                        { url: cinematicTemplateUrl, weight: 0.5 } // 9-shot layout template\n                    ],\n                    modelSettings: {\n                        aspectRatio: '16:9', // Widescreen for cinematic output\n                        resolution: '2K'\n                    }\n                })\n            })\n\n            const result = await response.json()\n\n            if (!response.ok) {\n                throw new Error(result.error || 'Failed to generate cinematic grid')\n            }\n\n            toast({\n                title: \"9-Shot Cinematic Generated!\",\n                description: \"Grid saved to gallery. Use 'Extract to Gallery' to split into individual shots.\"\n            })\n\n            // Refresh gallery to show the new image\n            setTimeout(async () => {\n                await useUnifiedGalleryStore.getState().refreshGallery()\n            }, 1000)\n        } catch (error) {\n            console.error('Cinematic grid generation error:', error)\n            toast({\n                title: \"Generation Failed\",\n                description: error instanceof Error ? error.message : \"An error occurred\",\n                variant: \"destructive\"\n            })\n        } finally {\n            setGeneratingCinematicId(null)\n        }\n    }, [generatingCinematicId, toast])\n\n    // Sidebar collapsed state from store (persisted)\n    const isSidebarCollapsed = useUnifiedGalleryStore(state => state.isSidebarCollapsed)\n    const setIsSidebarCollapsed = useUnifiedGalleryStore(state => state.setIsSidebarCollapsed)\n\n    // Hydrate UI preferences from localStorage after mount (SSR compatibility)\n    useEffect(() => {\n        useUnifiedGalleryStore.getState().hydrateFromStorage()\n        useUnifiedGalleryStore.getState().loadFolders()\n    }, [])\n\n    // Get uncategorized count\n    const uncategorizedCount = getUncategorizedCount()\n\n    // Handle moving single image to folder\n    const handleMoveToFolder = async (imageId: string, folderId: string | null) => {\n        await handleMoveImages([imageId], folderId)\n    }\n\n    // Handle extracting frames from a composite image\n    const handleExtractFrames = useCallback(async (imageUrl: string) => {\n        toast({\n            title: \"Extracting Frames\",\n            description: \"Analyzing image for 3\u00d73 grid...\"\n        })\n\n        try {\n            const result = await autoExtractFrames(imageUrl, '16:9')\n\n            if (!result.success) {\n                toast({\n                    title: \"Detection Failed\",\n                    description: \"Could not detect grid separators. Use Layout tab for manual extraction.\",\n                    variant: \"destructive\"\n                })\n                return\n            }\n\n            if (result.confidence === 'low') {\n                toast({\n                    title: \"Low Confidence\",\n                    description: \"Grid detection uncertain. Consider using Layout tab for manual adjustment.\",\n                    variant: \"destructive\"\n                })\n                return\n            }\n\n            // Download the extracted frames\n            result.frames.forEach((frame, index) => {\n                const link = document.createElement('a')\n                link.href = frame.dataUrl\n                link.download = `frame_${index + 1}_r${frame.row + 1}_c${frame.col + 1}.png`\n                link.click()\n            })\n\n            toast({\n                title: \"Frames Extracted\",\n                description: `Successfully extracted ${result.frames.length} frames (gutter: ${result.detectedGutter}px)`\n            })\n        } catch (error) {\n            console.error('Frame extraction error:', error)\n            toast({\n                title: \"Extraction Failed\",\n                description: \"An error occurred during frame extraction.\",\n                variant: \"destructive\"\n            })\n        }\n    }, [toast])\n\n    // Handle extracting frames and saving to gallery\n    const handleExtractFramesToGallery = useCallback(async (imageUrl: string, parentImageId?: string) => {\n        toast({\n            title: \"Extracting Frames\",\n            description: \"Analyzing image and saving to gallery...\"\n        })\n\n        try {\n            const result = await autoExtractFrames(imageUrl, '16:9')\n\n            if (!result.success) {\n                toast({\n                    title: \"Detection Failed\",\n                    description: \"Could not detect grid separators. Use Layout tab for manual extraction.\",\n                    variant: \"destructive\"\n                })\n                return\n            }\n\n            if (result.confidence === 'low') {\n                toast({\n                    title: \"Low Confidence\",\n                    description: \"Grid detection uncertain. Consider using Layout tab for manual adjustment.\",\n                    variant: \"destructive\"\n                })\n                return\n            }\n\n            // Save each frame to the gallery via API\n            let savedCount = 0\n            for (const frame of result.frames) {\n                try {\n                    const response = await fetch('/api/gallery/save-frame', {\n                        method: 'POST',\n                        headers: { 'Content-Type': 'application/json' },\n                        body: JSON.stringify({\n                            imageData: frame.dataUrl,\n                            metadata: {\n                                parentId: parentImageId,\n                                row: frame.row,\n                                col: frame.col,\n                                aspectRatio: '16:9',\n                                width: 1920,\n                                height: 1080\n                            }\n                        })\n                    })\n\n                    if (response.ok) {\n                        savedCount++\n                    }\n                } catch (err) {\n                    console.error('Failed to save frame:', err)\n                }\n            }\n\n            if (savedCount > 0) {\n                toast({\n                    title: \"Frames Saved to Gallery\",\n                    description: `Successfully saved ${savedCount} of ${result.frames.length} frames. Refreshing...`\n                })\n\n                // Give the toast a moment to show, then refresh to show new images\n                setTimeout(async () => {\n                    await useUnifiedGalleryStore.getState().refreshGallery()\n                    toast({\n                        title: \"Gallery Updated\",\n                        description: `${savedCount} new frames are now in your gallery`\n                    })\n                }, 1000)\n            } else {\n                toast({\n                    title: \"Save Failed\",\n                    description: \"Could not save frames to gallery. Please try again.\",\n                    variant: \"destructive\"\n                })\n            }\n        } catch (error) {\n            console.error('Frame extraction error:', error)\n            toast({\n                title: \"Extraction Failed\",\n                description: \"An error occurred during frame extraction.\",\n                variant: \"destructive\"\n            })\n        }\n    }, [toast])\n\n    // Handle retry for failed generations\n    // Copies the prompt to clipboard and removes the failed entry\n    const handleRetryGeneration = useCallback(async (image: GeneratedImage) => {\n        // Copy prompt to clipboard for easy regeneration\n        if (image.prompt) {\n            try {\n                await navigator.clipboard.writeText(image.prompt)\n                toast({\n                    title: \"Prompt Copied\",\n                    description: \"Paste the prompt in Shot Creator to regenerate. Failed entry removed.\"\n                })\n            } catch {\n                toast({\n                    title: \"Retry Ready\",\n                    description: `Failed entry removed. Original prompt: \"${image.prompt.slice(0, 100)}${image.prompt.length > 100 ? '...' : ''}\"`\n                })\n            }\n        }\n\n        // Delete the failed entry\n        await handleDeleteImage(image.url || image.id)\n    }, [handleDeleteImage, toast])\n\n    // Grid size to CSS classes mapping\n    // Mobile: small=3cols, medium=2cols, large=1col for clear differentiation\n    const getGridClasses = (size: GridSize): string => {\n        switch (size) {\n            case 'small':\n                return 'grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-8'\n            case 'medium':\n                return 'grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5'\n            case 'large':\n                return 'grid-cols-1 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'\n            default:\n                return 'grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5'\n        }\n    }\n\n    // Keyboard navigation for fullscreen modal\n    const navigateToImage = useCallback((direction: 'next' | 'previous') => {\n        if (!fullscreenImage || images.length <= 1) return\n\n        const currentIndex = images.findIndex((img: GeneratedImage) => img.url === fullscreenImage.url)\n        if (currentIndex === -1) return\n\n        let newIndex: number\n        if (direction === 'next') {\n            newIndex = currentIndex === images.length - 1 ? 0 : currentIndex + 1\n        } else {\n            newIndex = currentIndex === 0 ? images.length - 1 : currentIndex - 1\n        }\n\n        setFullscreenImage(images[newIndex])\n    }, [fullscreenImage, images, setFullscreenImage])\n\n    // Keyboard event handler\n    useEffect(() => {\n        const handleKeyDown = (event: KeyboardEvent) => {\n            if (!fullscreenImage) return\n\n            switch (event.key) {\n                case 'ArrowRight':\n                    event.preventDefault()\n                    navigateToImage('next')\n                    break\n                case 'ArrowLeft':\n                    event.preventDefault()\n                    navigateToImage('previous')\n                    break\n                case 'Escape':\n                    event.preventDefault()\n                    setFullscreenImage(null)\n                    break\n            }\n        }\n\n        if (fullscreenImage) {\n            document.addEventListener('keydown', handleKeyDown)\n        }\n\n        return () => {\n            document.removeEventListener('keydown', handleKeyDown)\n        }\n    }, [fullscreenImage, navigateToImage, setFullscreenImage])\n\n    // Minimal mode for embedded use\n    if (mode === 'minimal') {\n        return (\n            <div className={cn(\"w-full\", className)}>\n                <div className=\"grid grid-cols-2 md:grid-cols-4 gap-3\">\n                    {images.slice(0, 8).map((image: GeneratedImage) => (\n                        <ImageCard\n                            key={image.id}\n                            image={image}\n                            isSelected={false}\n                            onSelect={() => onImageSelect?.(image.url)}\n                            onZoom={() => setFullscreenImage(image)}\n                            onCopy={() => handleCopyImage(image.url)}\n                            onDownload={() => handleDownloadImage(image.url)}\n                            onDelete={() => handleDeleteImage(image.url)}\n                            onSendTo={currentTab ? (target) => handleSendTo(image.url, target) : undefined}\n                            onSetReference={async () => {\n                                const newRef = await showReferenceNamePrompt()\n                                if (newRef) {\n                                    await updateImageReference(image.id, newRef)\n                                }\n                            }}\n                            onEditReference={async () => {\n                                const newRef = await showReferenceNamePrompt(image.reference)\n                                if (newRef !== null) {\n                                    await updateImageReference(image.id, newRef)\n                                    toast({\n                                        title: newRef ? \"Reference Updated\" : \"Reference Cleared\",\n                                        description: newRef ? `Image tagged as ${newRef}` : \"Reference tag removed\"\n                                    })\n                                }\n                            }}\n                            onAddToLibrary={() => onSendToLibrary?.(image.url, image.id)}\n                            onMoveToFolder={(folderId) => handleMoveToFolder(image.id, folderId)}\n                            onExtractFrames={() => handleExtractFrames(image.url)}\n                            onExtractFramesToGallery={() => handleExtractFramesToGallery(image.url, image.id)}\n                            onRemoveBackground={() => handleRemoveBackground(image)}\n                            isRemovingBackground={removingBackgroundId === image.id}\n                            currentFolderId={image.folderId}\n                            folders={folders}\n                            showActions={true}\n                            useNativeAspectRatio={useNativeAspectRatio}\n                            gridSize={gridSize}\n                            onRetry={() => handleRetryGeneration(image)}\n                        />\n                    ))}\n                </div>\n            </div>\n        )\n    }\n\n    // Get current folder name for display\n    const currentFolderName = currentFolderId\n        ? folders.find(f => f.id === currentFolderId)?.name || 'Uncategorized'\n        : undefined\n\n    return (\n        <>\n            {/* Mobile Folder Menu */}\n            <MobileFolderMenu\n                open={isMobileFolderMenuOpen}\n                folders={folders}\n                currentFolderId={currentFolderId}\n                uncategorizedCount={uncategorizedCount}\n                totalImages={totalDatabaseCount}\n                isLoading={isFoldersLoading}\n                onOpenChange={setIsMobileFolderMenuOpen}\n                onFolderSelect={setCurrentFolder}\n                onCreateFolder={openCreateModal}\n            />\n\n            {/* Folder Manager Modal */}\n            <FolderManagerModal\n                mode={modalMode}\n                folder={selectedFolder}\n                onClose={closeModal}\n                onCreate={handleCreateFolder}\n                onUpdate={handleUpdateFolder}\n                onDelete={handleDeleteFolder}\n            />\n\n            {/* Main Gallery Layout */}\n            <div className=\"md:flex md:flex-row md:h-full w-full\">\n                {/* Desktop Folder Sidebar */}\n                <div className=\"hidden md:block\">\n                    <FolderSidebar\n                        folders={folders}\n                        currentFolderId={currentFolderId}\n                        uncategorizedCount={uncategorizedCount}\n                        totalImages={totalDatabaseCount}\n                        isLoading={isFoldersLoading}\n                        onFolderSelect={setCurrentFolder}\n                        onCreateFolder={openCreateModal}\n                        onEditFolder={openEditModal}\n                        onDeleteFolder={openDeleteModal}\n                        collapsed={isSidebarCollapsed}\n                        onToggleCollapse={() => setIsSidebarCollapsed(!isSidebarCollapsed)}\n                    />\n                </div>\n\n                {/* Gallery Content */}\n                <Card className={cn(\"md:flex-1 md:h-full flex flex-col\", className)}>\n                    <GalleryHeader\n                        totalImages={totalImages}\n                        totalDatabaseCount={totalDatabaseCount}\n                        totalCredits={totalCredits}\n                        searchQuery={filters.searchQuery}\n                        currentFolderName={currentFolderName}\n                        onSearchChange={handleSearchChange}\n                        selectedCount={selectedImages.length}\n                        gridSize={gridSize}\n                        useNativeAspectRatio={useNativeAspectRatio}\n                        folders={folders}\n                        onSelectAll={handleSelectAll}\n                        onClearSelection={handleClearSelection}\n                        onDeleteSelected={handleDeleteSelected}\n                        onGridSizeChange={setGridSize}\n                        onAspectRatioChange={setUseNativeAspectRatio}\n                        onOpenMobileMenu={() => setIsMobileFolderMenuOpen(true)}\n                        onMoveToFolder={async (folderId) => {\n                            // Convert selected image URLs to IDs\n                            const imageIds = selectedImages\n                                .map(url => images.find(img => img.url === url)?.id)\n                                .filter((id): id is string => !!id)\n                            if (imageIds.length > 0) {\n                                await handleMoveImages(imageIds, folderId)\n                                handleClearSelection()\n                                toast({\n                                    title: \"Images Moved\",\n                                    description: `${imageIds.length} images moved to ${folderId ? folders.find(f => f.id === folderId)?.name || 'folder' : 'Uncategorized'}`\n                                })\n                            }\n                        }}\n                        onBulkDownload={handleBulkDownload}\n                        onCreateFolder={openCreateModal}\n                    />\n\n                    <CardContent className=\"flex-1 flex flex-col md:overflow-hidden\">\n                        {isLoading ? (\n                            <div className=\"text-center py-12\">\n                                <LoadingSpinner size=\"xl\" color=\"accent\" className=\"mx-auto mb-4\" />\n                                <p className=\"text-muted-foreground\">Loading gallery...</p>\n                            </div>\n                        ) : images.length === 0 ? (\n                            <div className=\"text-center py-12\">\n                                <ImageIcon className=\"w-12 h-12 mx-auto mb-4 text-muted-foreground\" />\n                                <p className=\"text-muted-foreground\">No images generated yet</p>\n                                <p className=\"text-sm text-muted-foreground mt-2\">\n                                    Start creating images in Shot Creator or Shot Editor\n                                </p>\n                            </div>\n                        ) : (\n                            <>\n                                {isMobile ? (\n                                    <div className={cn(\"grid gap-4 pb-4\", getGridClasses(gridSize))}>\n                                        {paginatedImages.map((image: GeneratedImage) => (\n                                            <ImageCard\n                                                key={image.id}\n                                                image={image}\n                                                isSelected={selectedImages.includes(image.url)}\n                                                onSelect={() => handleImageSelect(image.url)}\n                                                onZoom={() => setFullscreenImage(image)}\n                                                onCopy={() => handleCopyImage(image.url)}\n                                                onDownload={() => handleDownloadImage(image.url)}\n                                                onDelete={() => handleDeleteImage(image.url)}\n                                                onSendTo={currentTab ? (target) => handleSendTo(image.url, target) : undefined}\n                                                onSetReference={async () => {\n                                                    const newRef = await showReferenceNamePrompt()\n                                                    if (newRef) {\n                                                        await updateImageReference(image.id, newRef)\n                                                    }\n                                                }}\n                                                onEditReference={async () => {\n                                                    const newRef = await showReferenceNamePrompt(image.reference)\n                                                    if (newRef !== null) {\n                                                        await updateImageReference(image.id, newRef)\n                                                        toast({\n                                                            title: newRef ? \"Reference Updated\" : \"Reference Cleared\",\n                                                            description: newRef ? `Image tagged as ${newRef}` : \"Reference tag removed\"\n                                                        })\n                                                    }\n                                                }}\n                                                onAddToLibrary={() => {\n                                                    if (onSendToLibrary) {\n                                                        onSendToLibrary(image.url, image.id)\n                                                    }\n                                                }}\n                                                onMoveToFolder={(folderId) => handleMoveToFolder(image.id, folderId)}\n                                                onExtractFrames={() => handleExtractFrames(image.url)}\n                                                onExtractFramesToGallery={() => handleExtractFramesToGallery(image.url, image.id)}\n                                                onRemoveBackground={() => handleRemoveBackground(image)}\n                                                isRemovingBackground={removingBackgroundId === image.id}\n                                                currentFolderId={image.folderId}\n                                                folders={folders}\n                                                showActions={true}\n                                                useNativeAspectRatio={useNativeAspectRatio}\n                                                gridSize={gridSize}\n                                                onRetry={() => handleRetryGeneration(image)}\n                                            />\n                                        ))}\n                                    </div>\n                                ) : (\n                                    <ScrollArea className=\"flex-1\">\n                                        <div className={cn(\"grid gap-4\", getGridClasses(gridSize))}>\n                                            {paginatedImages.map((image: GeneratedImage) => (\n                                                <ImageCard\n                                                    key={image.id}\n                                                    image={image}\n                                                    isSelected={selectedImages.includes(image.url)}\n                                                    onSelect={() => handleImageSelect(image.url)}\n                                                    onZoom={() => setFullscreenImage(image)}\n                                                    onCopy={() => handleCopyImage(image.url)}\n                                                    onDownload={() => handleDownloadImage(image.url)}\n                                                    onDelete={() => handleDeleteImage(image.url)}\n                                                    onSendTo={currentTab ? (target) => handleSendTo(image.url, target) : undefined}\n                                                    onSetReference={async () => {\n                                                        const newRef = await showReferenceNamePrompt()\n                                                        if (newRef) {\n                                                            await updateImageReference(image.id, newRef)\n                                                        }\n                                                    }}\n                                                    onEditReference={async () => {\n                                                        const newRef = await showReferenceNamePrompt(image.reference)\n                                                        if (newRef !== null) {\n                                                            await updateImageReference(image.id, newRef)\n                                                            toast({\n                                                                title: newRef ? \"Reference Updated\" : \"Reference Cleared\",\n                                                                description: newRef ? `Image tagged as ${newRef}` : \"Reference tag removed\"\n                                                            })\n                                                        }\n                                                    }}\n                                                    onAddToLibrary={() => {\n                                                        if (onSendToLibrary) {\n                                                            onSendToLibrary(image.url, image.id)\n                                                        }\n                                                    }}\n                                                    onMoveToFolder={(folderId) => handleMoveToFolder(image.id, folderId)}\n                                                    onExtractFrames={() => handleExtractFrames(image.url)}\n                                                    onExtractFramesToGallery={() => handleExtractFramesToGallery(image.url, image.id)}\n                                                    onRemoveBackground={() => handleRemoveBackground(image)}\n                                                    isRemovingBackground={removingBackgroundId === image.id}\n                                                    currentFolderId={image.folderId}\n                                                    folders={folders}\n                                                    showActions={true}\n                                                    useNativeAspectRatio={useNativeAspectRatio}\n                                                    gridSize={gridSize}\n                                                    onRetry={() => handleRetryGeneration(image)}\n                                                />\n                                            ))}\n                                        </div>\n                                    </ScrollArea>\n                                )}\n\n                                {hasMore && (\n                                    <div className=\"flex justify-center py-8\">\n                                        <LoadMoreButton\n                                            onClick={() => loadMoreImages()}\n                                            loading={isLoadingMore}\n                                            hasMore={hasMore}\n                                        />\n                                    </div>\n                                )}\n\n                                {!hasMore && images.length > 0 && (\n                                    <div className=\"text-center py-8\">\n                                        <div className=\"inline-flex items-center gap-2 px-4 py-2 rounded-full bg-card/50 border border-border/50 text-muted-foreground text-sm\">\n                                            <span className=\"text-emerald-400\">\u2713</span>\n                                            All {images.length} images loaded\n                                        </div>\n                                    </div>\n                                )}\n                            </>\n                        )}\n                    </CardContent>\n\n                    {/* Fullscreen Image Modal */}\n                    {fullscreenImage && (\n                        <FullscreenModal\n                            fullscreenImage={fullscreenImage}\n                            images={images}\n                            setFullscreenImage={setFullscreenImage}\n                            onClose={() => setFullscreenImage(null)}\n                            onNavigate={(direction: 'next' | 'previous') => navigateToImage(direction)}\n                            onCopyImage={handleCopyImage}\n                            onDownloadImage={handleDownloadImage}\n                            onDeleteImage={handleDeleteImage}\n                            onSendTo={currentTab ? (url: string, target: string) => handleSendTo(url, target) : (() => { })}\n                            onSetReference={async () => {\n                                const newRef = await showReferenceNamePrompt()\n                                if (newRef) {\n                                    await updateImageReference(fullscreenImage.id, newRef)\n                                }\n                            }}\n                            onAddToLibrary={onSendToLibrary && fullscreenImage ? () => onSendToLibrary(fullscreenImage.url, fullscreenImage.id) : undefined}\n                            onExtractFrames={() => handleExtractFrames(fullscreenImage.url)}\n                            onExtractFramesToGallery={() => handleExtractFramesToGallery(fullscreenImage.url, fullscreenImage.id)}\n                            onRemoveBackground={() => handleRemoveBackground(fullscreenImage)}\n                            isRemovingBackground={removingBackgroundId === fullscreenImage.id}\n                            onGenerateCinematicGrid={() => handleGenerateCinematicGrid(fullscreenImage)}\n                            isGeneratingCinematic={generatingCinematicId === fullscreenImage.id}\n                            showReferenceNamePrompt={showReferenceNamePrompt}\n                        />\n                    )}\n\n                    {/* Bulk Download Modal */}\n                    <BulkDownloadModal\n                        open={downloadModalOpen}\n                        onOpenChange={setDownloadModalOpen}\n                        imageCount={selectedImages.length}\n                        current={downloadProgress?.current || 0}\n                        status={downloadProgress?.status || 'downloading'}\n                        error={downloadProgress?.error}\n                    />\n                </Card>\n            </div>\n        </>\n    )\n}",
        "timestamp": "2025-12-25T18:57:10.314069"
      },
      "worktree_state": {
        "content": "'use client'\n\nimport { useEffect, useCallback, useState } from 'react'\nimport { Card, CardContent } from '@/components/ui/card'\nimport { ScrollArea } from '@/components/ui/scroll-area'\nimport { LoadingSpinner } from '@/components/ui/loading-spinner'\nimport { ImageIcon } from 'lucide-react'\nimport { cn } from '@/utils/utils'\nimport { useReferenceNamePrompt } from '@/components/providers/PromptProvider'\nimport { useIsMobile } from '@/hooks/use-mobile'\nimport { useToast } from '@/hooks/use-toast'\nimport { autoExtractFrames } from '@/features/layout-annotation/services/grid-detector'\nimport { LoadMoreButton } from './LoadMoreButton'\nimport { useGalleryLogic } from \"../../hooks/useGalleryLogic\"\nimport { ImageCard } from \"./ImageCard\"\nimport { GalleryHeader } from \"./GalleryHeader\"\nimport FullscreenModal from \"./FullScreenModal\"\nimport { FolderSidebar } from \"./FolderSidebar\"\nimport { MobileFolderMenu } from \"./MobileFolderMenu\"\nimport { FolderManagerModal } from \"./FolderManagerModal\"\nimport { BulkDownloadModal } from \"./BulkDownloadModal\"\nimport { BulkActionsToolbar } from \"./BulkActionsToolbar\"\nimport { useFolderManager } from \"../../hooks/useFolderManager\"\nimport { GeneratedImage, useUnifiedGalleryStore, GridSize } from '../../store/unified-gallery-store'\n\nexport interface UnifiedImageGalleryProps {\n    currentTab?: 'shot-creator' | 'shot-animator' | 'layout-annotation' | 'gallery' | 'story-creator'\n    mode?: 'minimal' | 'full'\n    isLoading?: boolean\n    onSendToTab?: (imageUrl: string, targetTab: string) => void\n    onUseAsReference?: (imageUrl: string) => void\n    onSendToLibrary?: (imageUrl: string, galleryId: string) => void\n    onSendToLayoutAnnotation?: (imageUrl: string) => void\n    onSendToShotAnimator?: (imageUrl: string) => void\n    onImageSelect?: (imageUrl: string) => void\n    className?: string\n}\n\nexport function UnifiedImageGallery({\n    currentTab,\n    mode = 'full',\n    isLoading = false,\n    onSendToTab,\n    onUseAsReference,\n    onSendToShotAnimator,\n    onSendToLayoutAnnotation,\n    onSendToLibrary,\n    onImageSelect,\n    className\n}: UnifiedImageGalleryProps) {\n    const {\n        images,\n        paginatedImages,\n        filters,\n        fullscreenImage,\n        totalImages,\n        totalCredits,\n        handleCopyImage,\n        handleDownloadImage,\n        handleDeleteImage,\n        handleSendTo,\n        handleSearchChange,\n        setFullscreenImage,\n        selectedImages,\n        handleSelectAll,\n        handleClearSelection,\n        handleDeleteSelected,\n        handleImageSelect,\n        handleImageSelectWithModifiers,\n        updateImageReference,\n        downloadModalOpen,\n        downloadProgress,\n        handleBulkDownload,\n        setDownloadModalOpen\n    } = useGalleryLogic(onSendToTab, onUseAsReference, onSendToShotAnimator, onSendToLayoutAnnotation, onSendToLibrary, onImageSelect)\n\n    const showReferenceNamePrompt = useReferenceNamePrompt()\n    const { toast } = useToast()\n\n    // Get grid size, pagination, and database count from store\n    const gridSize = useUnifiedGalleryStore(state => state.gridSize)\n    const setGridSize = useUnifiedGalleryStore(state => state.setGridSize)\n    const totalDatabaseCount = useUnifiedGalleryStore(state => state.totalDatabaseCount)\n    const useNativeAspectRatio = useUnifiedGalleryStore(state => state.useNativeAspectRatio)\n    const setUseNativeAspectRatio = useUnifiedGalleryStore(state => state.setUseNativeAspectRatio)\n\n    // Get infinite scroll state from store\n    const hasMore = useUnifiedGalleryStore(state => state.hasMore)\n    const isLoadingMore = useUnifiedGalleryStore(state => state.isLoadingMore)\n    const loadMoreImages = useUnifiedGalleryStore(state => state.loadMoreImages)\n\n    // Folder state from store\n    const folders = useUnifiedGalleryStore(state => state.folders)\n    const currentFolderId = useUnifiedGalleryStore(state => state.currentFolderId)\n    const isFoldersLoading = useUnifiedGalleryStore(state => state.isFoldersLoading)\n    const setCurrentFolder = useUnifiedGalleryStore(state => state.setCurrentFolder)\n    const getUncategorizedCount = useUnifiedGalleryStore(state => state.getUncategorizedCount)\n\n    // Folder manager hook\n    const {\n        modalMode,\n        selectedFolder,\n        openCreateModal,\n        openEditModal,\n        openDeleteModal,\n        closeModal,\n        handleCreateFolder,\n        handleUpdateFolder,\n        handleDeleteFolder,\n        handleMoveImages,\n    } = useFolderManager()\n\n    // Mobile detection for responsive scroll behavior\n    const isMobile = useIsMobile()\n\n    // Local UI state\n    const [isMobileFolderMenuOpen, setIsMobileFolderMenuOpen] = useState(false)\n    const [removingBackgroundId, setRemovingBackgroundId] = useState<string | null>(null)\n    const [generatingCinematicId, setGeneratingCinematicId] = useState<string | null>(null)\n\n    // Handle background removal\n    const handleRemoveBackground = useCallback(async (image: GeneratedImage) => {\n        if (removingBackgroundId) return // Prevent multiple concurrent removals\n\n        setRemovingBackgroundId(image.id)\n        toast({\n            title: \"Removing Background\",\n            description: \"Processing image... (3 pts)\"\n        })\n\n        try {\n            const response = await fetch('/api/tools/remove-background', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    imageUrl: image.url,\n                    galleryId: image.id\n                })\n            })\n\n            const result = await response.json()\n\n            if (!response.ok) {\n                throw new Error(result.error || 'Failed to remove background')\n            }\n\n            toast({\n                title: \"Background Removed!\",\n                description: \"New image saved to gallery. Refreshing...\"\n            })\n\n            // Refresh gallery to show the new image\n            setTimeout(async () => {\n                await useUnifiedGalleryStore.getState().refreshGallery()\n            }, 500)\n        } catch (error) {\n            console.error('Background removal error:', error)\n            toast({\n                title: \"Remove Background Failed\",\n                description: error instanceof Error ? error.message : \"An error occurred\",\n                variant: \"destructive\"\n            })\n        } finally {\n            setRemovingBackgroundId(null)\n        }\n    }, [removingBackgroundId, toast])\n\n    // Handle 9-Shot Cinematic Grid generation\n    const handleGenerateCinematicGrid = useCallback(async (image: GeneratedImage) => {\n        if (generatingCinematicId) return // Prevent multiple concurrent generations\n\n        setGeneratingCinematicId(image.id)\n        toast({\n            title: \"Generating 9-Shot Cinematic\",\n            description: \"Creating cinematic grid... This may take a moment.\"\n        })\n\n        try {\n            // Template image for 9-shot cinematic layout\n            // Use NEXT_PUBLIC_SITE_URL for public access, fallback to production URL\n            const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://directorspalette.app'\n            const cinematicTemplateUrl = `${siteUrl}/templates/cinematic-reference.png`\n\n            // Proper cinematic grid prompt with detailed instructions\n            const cinematicPrompt = `<instruction> Analyze the entire composition of the input image. Identify all key subjects present (whether it's a single person, a group/couple, a vehicle, or a specific object) and their spatial relationship or interaction. Generate a cohesive 3x3 cinematic contact sheet featuring 9 distinct camera shots of exactly these subjects in the same environment. These shots must cover the full range from wide environmental framing to intimate close detail. Adapt the framing to fit the content: if the subject is a group, keep the group together; if the subject is an object, frame the entire object appropriately. Row 1 should consist of three progressively closer environmental/context shots, beginning with a very distant wide view, followed by a full-body view, and then a slightly tighter long-framing view. Row 2 should cover the core subject area: a waist-up framing, a chest-up framing, and a tight facial or frontal framing. Row 3 should focus on intimate details and angle variations: a macro detail shot, a dramatic low-angle upward shot, and a high-angle downward shot. Ensure strict consistency across all 9 frames: identical subjects, identical outfits, identical environment, identical lighting, and coherent scene continuity. Depth of field should become increasingly shallow as the framing moves closer, especially in the final row. </instruction> A professional 3x3 cinematic storyboard grid containing 9 panels, covering the entire visual range from wide environmental shots to macro detail. No labels, text, overlays, icons, or shot-type captions in any frame. Only clean cinematic imagery. Top row: wide environment, full-body, medium-long view. Middle row: waist-up, chest-up, tight face/front framing. Bottom row: macro detail, low-angle, high-angle. All frames must feature consistent photorealistic textures, cinematic color grading, and faithful continuity of subjects and scene. maintain the provided style`\n\n            // Send BOTH the user's selected image AND the template image\n            const response = await fetch('/api/generation/image', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    model: 'nano-banana-pro', // Use Nano Banana Pro for best quality\n                    prompt: cinematicPrompt,\n                    referenceImages: [\n                        { url: image.url, weight: 0.8 },          // User's selected image\n                        { url: cinematicTemplateUrl, weight: 0.5 } // 9-shot layout template\n                    ],\n                    modelSettings: {\n                        aspectRatio: '16:9', // Widescreen for cinematic output\n                        resolution: '2K'\n                    }\n                })\n            })\n\n            const result = await response.json()\n\n            if (!response.ok) {\n                throw new Error(result.error || 'Failed to generate cinematic grid')\n            }\n\n            toast({\n                title: \"9-Shot Cinematic Generated!\",\n                description: \"Grid saved to gallery. Use 'Extract to Gallery' to split into individual shots.\"\n            })\n\n            // Refresh gallery to show the new image\n            setTimeout(async () => {\n                await useUnifiedGalleryStore.getState().refreshGallery()\n            }, 1000)\n        } catch (error) {\n            console.error('Cinematic grid generation error:', error)\n            toast({\n                title: \"Generation Failed\",\n                description: error instanceof Error ? error.message : \"An error occurred\",\n                variant: \"destructive\"\n            })\n        } finally {\n            setGeneratingCinematicId(null)\n        }\n    }, [generatingCinematicId, toast])\n\n    // Sidebar collapsed state from store (persisted)\n    const isSidebarCollapsed = useUnifiedGalleryStore(state => state.isSidebarCollapsed)\n    const setIsSidebarCollapsed = useUnifiedGalleryStore(state => state.setIsSidebarCollapsed)\n\n    // Hydrate UI preferences from localStorage after mount (SSR compatibility)\n    useEffect(() => {\n        useUnifiedGalleryStore.getState().hydrateFromStorage()\n        useUnifiedGalleryStore.getState().loadFolders()\n    }, [])\n\n    // Get uncategorized count\n    const uncategorizedCount = getUncategorizedCount()\n\n    // Handle moving single image to folder\n    const handleMoveToFolder = async (imageId: string, folderId: string | null) => {\n        await handleMoveImages([imageId], folderId)\n    }\n\n    // Handle bulk moving selected images to folder (for BulkActionsToolbar)\n    const handleBulkMoveToFolder = useCallback(async (folderId: string | null) => {\n        // Convert selected image URLs to IDs\n        const imageIds = selectedImages\n            .map(url => images.find(img => img.url === url)?.id)\n            .filter((id): id is string => !!id)\n        if (imageIds.length > 0) {\n            await handleMoveImages(imageIds, folderId)\n            handleClearSelection()\n            toast({\n                title: \"Images Moved\",\n                description: `${imageIds.length} images moved to ${folderId ? folders.find(f => f.id === folderId)?.name || 'folder' : 'Uncategorized'}`\n            })\n        }\n    }, [selectedImages, images, handleMoveImages, handleClearSelection, folders, toast])\n\n    // Handle extracting frames from a composite image\n    const handleExtractFrames = useCallback(async (imageUrl: string) => {\n        toast({\n            title: \"Extracting Frames\",\n            description: \"Analyzing image for 3\u00d73 grid...\"\n        })\n\n        try {\n            const result = await autoExtractFrames(imageUrl, '16:9')\n\n            if (!result.success) {\n                toast({\n                    title: \"Detection Failed\",\n                    description: \"Could not detect grid separators. Use Layout tab for manual extraction.\",\n                    variant: \"destructive\"\n                })\n                return\n            }\n\n            if (result.confidence === 'low') {\n                toast({\n                    title: \"Low Confidence\",\n                    description: \"Grid detection uncertain. Consider using Layout tab for manual adjustment.\",\n                    variant: \"destructive\"\n                })\n                return\n            }\n\n            // Download the extracted frames\n            result.frames.forEach((frame, index) => {\n                const link = document.createElement('a')\n                link.href = frame.dataUrl\n                link.download = `frame_${index + 1}_r${frame.row + 1}_c${frame.col + 1}.png`\n                link.click()\n            })\n\n            toast({\n                title: \"Frames Extracted\",\n                description: `Successfully extracted ${result.frames.length} frames (gutter: ${result.detectedGutter}px)`\n            })\n        } catch (error) {\n            console.error('Frame extraction error:', error)\n            toast({\n                title: \"Extraction Failed\",\n                description: \"An error occurred during frame extraction.\",\n                variant: \"destructive\"\n            })\n        }\n    }, [toast])\n\n    // Handle extracting frames and saving to gallery\n    const handleExtractFramesToGallery = useCallback(async (imageUrl: string, parentImageId?: string) => {\n        toast({\n            title: \"Extracting Frames\",\n            description: \"Analyzing image and saving to gallery...\"\n        })\n\n        try {\n            const result = await autoExtractFrames(imageUrl, '16:9')\n\n            if (!result.success) {\n                toast({\n                    title: \"Detection Failed\",\n                    description: \"Could not detect grid separators. Use Layout tab for manual extraction.\",\n                    variant: \"destructive\"\n                })\n                return\n            }\n\n            if (result.confidence === 'low') {\n                toast({\n                    title: \"Low Confidence\",\n                    description: \"Grid detection uncertain. Consider using Layout tab for manual adjustment.\",\n                    variant: \"destructive\"\n                })\n                return\n            }\n\n            // Save each frame to the gallery via API\n            let savedCount = 0\n            for (const frame of result.frames) {\n                try {\n                    const response = await fetch('/api/gallery/save-frame', {\n                        method: 'POST',\n                        headers: { 'Content-Type': 'application/json' },\n                        body: JSON.stringify({\n                            imageData: frame.dataUrl,\n                            metadata: {\n                                parentId: parentImageId,\n                                row: frame.row,\n                                col: frame.col,\n                                aspectRatio: '16:9',\n                                width: 1920,\n                                height: 1080\n                            }\n                        })\n                    })\n\n                    if (response.ok) {\n                        savedCount++\n                    }\n                } catch (err) {\n                    console.error('Failed to save frame:', err)\n                }\n            }\n\n            if (savedCount > 0) {\n                toast({\n                    title: \"Frames Saved to Gallery\",\n                    description: `Successfully saved ${savedCount} of ${result.frames.length} frames. Refreshing...`\n                })\n\n                // Give the toast a moment to show, then refresh to show new images\n                setTimeout(async () => {\n                    await useUnifiedGalleryStore.getState().refreshGallery()\n                    toast({\n                        title: \"Gallery Updated\",\n                        description: `${savedCount} new frames are now in your gallery`\n                    })\n                }, 1000)\n            } else {\n                toast({\n                    title: \"Save Failed\",\n                    description: \"Could not save frames to gallery. Please try again.\",\n                    variant: \"destructive\"\n                })\n            }\n        } catch (error) {\n            console.error('Frame extraction error:', error)\n            toast({\n                title: \"Extraction Failed\",\n                description: \"An error occurred during frame extraction.\",\n                variant: \"destructive\"\n            })\n        }\n    }, [toast])\n\n    // Handle retry for failed generations\n    // Copies the prompt to clipboard and removes the failed entry\n    const handleRetryGeneration = useCallback(async (image: GeneratedImage) => {\n        // Copy prompt to clipboard for easy regeneration\n        if (image.prompt) {\n            try {\n                await navigator.clipboard.writeText(image.prompt)\n                toast({\n                    title: \"Prompt Copied\",\n                    description: \"Paste the prompt in Shot Creator to regenerate. Failed entry removed.\"\n                })\n            } catch {\n                toast({\n                    title: \"Retry Ready\",\n                    description: `Failed entry removed. Original prompt: \"${image.prompt.slice(0, 100)}${image.prompt.length > 100 ? '...' : ''}\"`\n                })\n            }\n        }\n\n        // Delete the failed entry\n        await handleDeleteImage(image.url || image.id)\n    }, [handleDeleteImage, toast])\n\n    // Grid size to CSS classes mapping\n    // Mobile: small=3cols, medium=2cols, large=1col for clear differentiation\n    const getGridClasses = (size: GridSize): string => {\n        switch (size) {\n            case 'small':\n                return 'grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-8'\n            case 'medium':\n                return 'grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5'\n            case 'large':\n                return 'grid-cols-1 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'\n            default:\n                return 'grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5'\n        }\n    }\n\n    // Keyboard navigation for fullscreen modal\n    const navigateToImage = useCallback((direction: 'next' | 'previous') => {\n        if (!fullscreenImage || images.length <= 1) return\n\n        const currentIndex = images.findIndex((img: GeneratedImage) => img.url === fullscreenImage.url)\n        if (currentIndex === -1) return\n\n        let newIndex: number\n        if (direction === 'next') {\n            newIndex = currentIndex === images.length - 1 ? 0 : currentIndex + 1\n        } else {\n            newIndex = currentIndex === 0 ? images.length - 1 : currentIndex - 1\n        }\n\n        setFullscreenImage(images[newIndex])\n    }, [fullscreenImage, images, setFullscreenImage])\n\n    // Keyboard event handler\n    useEffect(() => {\n        const handleKeyDown = (event: KeyboardEvent) => {\n            if (!fullscreenImage) return\n\n            switch (event.key) {\n                case 'ArrowRight':\n                    event.preventDefault()\n                    navigateToImage('next')\n                    break\n                case 'ArrowLeft':\n                    event.preventDefault()\n                    navigateToImage('previous')\n                    break\n                case 'Escape':\n                    event.preventDefault()\n                    setFullscreenImage(null)\n                    break\n            }\n        }\n\n        if (fullscreenImage) {\n            document.addEventListener('keydown', handleKeyDown)\n        }\n\n        return () => {\n            document.removeEventListener('keydown', handleKeyDown)\n        }\n    }, [fullscreenImage, navigateToImage, setFullscreenImage])\n\n    // Minimal mode for embedded use\n    if (mode === 'minimal') {\n        return (\n            <div className={cn(\"w-full\", className)}>\n                <div className=\"grid grid-cols-2 md:grid-cols-4 gap-3\">\n                    {images.slice(0, 8).map((image: GeneratedImage) => (\n                        <ImageCard\n                            key={image.id}\n                            image={image}\n                            isSelected={false}\n                            onSelect={() => onImageSelect?.(image.url)}\n                            onZoom={() => setFullscreenImage(image)}\n                            onCopy={() => handleCopyImage(image.url)}\n                            onDownload={() => handleDownloadImage(image.url)}\n                            onDelete={() => handleDeleteImage(image.url)}\n                            onSendTo={currentTab ? (target) => handleSendTo(image.url, target) : undefined}\n                            onSetReference={async () => {\n                                const newRef = await showReferenceNamePrompt()\n                                if (newRef) {\n                                    await updateImageReference(image.id, newRef)\n                                }\n                            }}\n                            onEditReference={async () => {\n                                const newRef = await showReferenceNamePrompt(image.reference)\n                                if (newRef !== null) {\n                                    await updateImageReference(image.id, newRef)\n                                    toast({\n                                        title: newRef ? \"Reference Updated\" : \"Reference Cleared\",\n                                        description: newRef ? `Image tagged as ${newRef}` : \"Reference tag removed\"\n                                    })\n                                }\n                            }}\n                            onAddToLibrary={() => onSendToLibrary?.(image.url, image.id)}\n                            onMoveToFolder={(folderId) => handleMoveToFolder(image.id, folderId)}\n                            onExtractFrames={() => handleExtractFrames(image.url)}\n                            onExtractFramesToGallery={() => handleExtractFramesToGallery(image.url, image.id)}\n                            onRemoveBackground={() => handleRemoveBackground(image)}\n                            isRemovingBackground={removingBackgroundId === image.id}\n                            currentFolderId={image.folderId}\n                            folders={folders}\n                            showActions={true}\n                            useNativeAspectRatio={useNativeAspectRatio}\n                            gridSize={gridSize}\n                            onRetry={() => handleRetryGeneration(image)}\n                        />\n                    ))}\n                </div>\n            </div>\n        )\n    }\n\n    // Get current folder name for display\n    const currentFolderName = currentFolderId\n        ? folders.find(f => f.id === currentFolderId)?.name || 'Uncategorized'\n        : undefined\n\n    return (\n        <>\n            {/* Mobile Folder Menu */}\n            <MobileFolderMenu\n                open={isMobileFolderMenuOpen}\n                folders={folders}\n                currentFolderId={currentFolderId}\n                uncategorizedCount={uncategorizedCount}\n                totalImages={totalDatabaseCount}\n                isLoading={isFoldersLoading}\n                onOpenChange={setIsMobileFolderMenuOpen}\n                onFolderSelect={setCurrentFolder}\n                onCreateFolder={openCreateModal}\n            />\n\n            {/* Folder Manager Modal */}\n            <FolderManagerModal\n                mode={modalMode}\n                folder={selectedFolder}\n                onClose={closeModal}\n                onCreate={handleCreateFolder}\n                onUpdate={handleUpdateFolder}\n                onDelete={handleDeleteFolder}\n            />\n\n            {/* Main Gallery Layout */}\n            <div className=\"md:flex md:flex-row md:h-full w-full\">\n                {/* Desktop Folder Sidebar */}\n                <div className=\"hidden md:block\">\n                    <FolderSidebar\n                        folders={folders}\n                        currentFolderId={currentFolderId}\n                        uncategorizedCount={uncategorizedCount}\n                        totalImages={totalDatabaseCount}\n                        isLoading={isFoldersLoading}\n                        onFolderSelect={setCurrentFolder}\n                        onCreateFolder={openCreateModal}\n                        onEditFolder={openEditModal}\n                        onDeleteFolder={openDeleteModal}\n                        collapsed={isSidebarCollapsed}\n                        onToggleCollapse={() => setIsSidebarCollapsed(!isSidebarCollapsed)}\n                    />\n                </div>\n\n                {/* Gallery Content */}\n                <Card className={cn(\"md:flex-1 md:h-full flex flex-col\", className)}>\n                    <GalleryHeader\n                        totalImages={totalImages}\n                        totalDatabaseCount={totalDatabaseCount}\n                        totalCredits={totalCredits}\n                        searchQuery={filters.searchQuery}\n                        currentFolderName={currentFolderName}\n                        onSearchChange={handleSearchChange}\n                        selectedCount={selectedImages.length}\n                        gridSize={gridSize}\n                        useNativeAspectRatio={useNativeAspectRatio}\n                        folders={folders}\n                        onSelectAll={handleSelectAll}\n                        onClearSelection={handleClearSelection}\n                        onDeleteSelected={handleDeleteSelected}\n                        onGridSizeChange={setGridSize}\n                        onAspectRatioChange={setUseNativeAspectRatio}\n                        onOpenMobileMenu={() => setIsMobileFolderMenuOpen(true)}\n                        onMoveToFolder={async (folderId) => {\n                            // Convert selected image URLs to IDs\n                            const imageIds = selectedImages\n                                .map(url => images.find(img => img.url === url)?.id)\n                                .filter((id): id is string => !!id)\n                            if (imageIds.length > 0) {\n                                await handleMoveImages(imageIds, folderId)\n                                handleClearSelection()\n                                toast({\n                                    title: \"Images Moved\",\n                                    description: `${imageIds.length} images moved to ${folderId ? folders.find(f => f.id === folderId)?.name || 'folder' : 'Uncategorized'}`\n                                })\n                            }\n                        }}\n                        onBulkDownload={handleBulkDownload}\n                        onCreateFolder={openCreateModal}\n                    />\n\n                    <CardContent className=\"flex-1 flex flex-col md:overflow-hidden\">\n                        {isLoading ? (\n                            <div className=\"text-center py-12\">\n                                <LoadingSpinner size=\"xl\" color=\"accent\" className=\"mx-auto mb-4\" />\n                                <p className=\"text-muted-foreground\">Loading gallery...</p>\n                            </div>\n                        ) : images.length === 0 ? (\n                            <div className=\"text-center py-12\">\n                                <ImageIcon className=\"w-12 h-12 mx-auto mb-4 text-muted-foreground\" />\n                                <p className=\"text-muted-foreground\">No images generated yet</p>\n                                <p className=\"text-sm text-muted-foreground mt-2\">\n                                    Start creating images in Shot Creator or Shot Editor\n                                </p>\n                            </div>\n                        ) : (\n                            <>\n                                {isMobile ? (\n                                    <div className={cn(\"grid gap-4 pb-4\", getGridClasses(gridSize))}>\n                                        {paginatedImages.map((image: GeneratedImage) => (\n                                            <ImageCard\n                                                key={image.id}\n                                                image={image}\n                                                isSelected={selectedImages.includes(image.url)}\n                                                onSelect={(e) => e ? handleImageSelectWithModifiers(image.url, e) : handleImageSelect(image.url)}\n                                                onZoom={() => setFullscreenImage(image)}\n                                                onCopy={() => handleCopyImage(image.url)}\n                                                onDownload={() => handleDownloadImage(image.url)}\n                                                onDelete={() => handleDeleteImage(image.url)}\n                                                onSendTo={currentTab ? (target) => handleSendTo(image.url, target) : undefined}\n                                                onSetReference={async () => {\n                                                    const newRef = await showReferenceNamePrompt()\n                                                    if (newRef) {\n                                                        await updateImageReference(image.id, newRef)\n                                                    }\n                                                }}\n                                                onEditReference={async () => {\n                                                    const newRef = await showReferenceNamePrompt(image.reference)\n                                                    if (newRef !== null) {\n                                                        await updateImageReference(image.id, newRef)\n                                                        toast({\n                                                            title: newRef ? \"Reference Updated\" : \"Reference Cleared\",\n                                                            description: newRef ? `Image tagged as ${newRef}` : \"Reference tag removed\"\n                                                        })\n                                                    }\n                                                }}\n                                                onAddToLibrary={() => {\n                                                    if (onSendToLibrary) {\n                                                        onSendToLibrary(image.url, image.id)\n                                                    }\n                                                }}\n                                                onMoveToFolder={(folderId) => handleMoveToFolder(image.id, folderId)}\n                                                onExtractFrames={() => handleExtractFrames(image.url)}\n                                                onExtractFramesToGallery={() => handleExtractFramesToGallery(image.url, image.id)}\n                                                onRemoveBackground={() => handleRemoveBackground(image)}\n                                                isRemovingBackground={removingBackgroundId === image.id}\n                                                currentFolderId={image.folderId}\n                                                folders={folders}\n                                                showActions={true}\n                                                useNativeAspectRatio={useNativeAspectRatio}\n                                                gridSize={gridSize}\n                                                onRetry={() => handleRetryGeneration(image)}\n                                            />\n                                        ))}\n                                    </div>\n                                ) : (\n                                    <ScrollArea className=\"flex-1\">\n                                        <div className={cn(\"grid gap-4\", getGridClasses(gridSize))}>\n                                            {paginatedImages.map((image: GeneratedImage) => (\n                                                <ImageCard\n                                                    key={image.id}\n                                                    image={image}\n                                                    isSelected={selectedImages.includes(image.url)}\n                                                    onSelect={(e) => e ? handleImageSelectWithModifiers(image.url, e) : handleImageSelect(image.url)}\n                                                    onZoom={() => setFullscreenImage(image)}\n                                                    onCopy={() => handleCopyImage(image.url)}\n                                                    onDownload={() => handleDownloadImage(image.url)}\n                                                    onDelete={() => handleDeleteImage(image.url)}\n                                                    onSendTo={currentTab ? (target) => handleSendTo(image.url, target) : undefined}\n                                                    onSetReference={async () => {\n                                                        const newRef = await showReferenceNamePrompt()\n                                                        if (newRef) {\n                                                            await updateImageReference(image.id, newRef)\n                                                        }\n                                                    }}\n                                                    onEditReference={async () => {\n                                                        const newRef = await showReferenceNamePrompt(image.reference)\n                                                        if (newRef !== null) {\n                                                            await updateImageReference(image.id, newRef)\n                                                            toast({\n                                                                title: newRef ? \"Reference Updated\" : \"Reference Cleared\",\n                                                                description: newRef ? `Image tagged as ${newRef}` : \"Reference tag removed\"\n                                                            })\n                                                        }\n                                                    }}\n                                                    onAddToLibrary={() => {\n                                                        if (onSendToLibrary) {\n                                                            onSendToLibrary(image.url, image.id)\n                                                        }\n                                                    }}\n                                                    onMoveToFolder={(folderId) => handleMoveToFolder(image.id, folderId)}\n                                                    onExtractFrames={() => handleExtractFrames(image.url)}\n                                                    onExtractFramesToGallery={() => handleExtractFramesToGallery(image.url, image.id)}\n                                                    onRemoveBackground={() => handleRemoveBackground(image)}\n                                                    isRemovingBackground={removingBackgroundId === image.id}\n                                                    currentFolderId={image.folderId}\n                                                    folders={folders}\n                                                    showActions={true}\n                                                    useNativeAspectRatio={useNativeAspectRatio}\n                                                    gridSize={gridSize}\n                                                    onRetry={() => handleRetryGeneration(image)}\n                                                />\n                                            ))}\n                                        </div>\n                                    </ScrollArea>\n                                )}\n\n                                {hasMore && (\n                                    <div className=\"flex justify-center py-8\">\n                                        <LoadMoreButton\n                                            onClick={() => loadMoreImages()}\n                                            loading={isLoadingMore}\n                                            hasMore={hasMore}\n                                        />\n                                    </div>\n                                )}\n\n                                {!hasMore && images.length > 0 && (\n                                    <div className=\"text-center py-8\">\n                                        <div className=\"inline-flex items-center gap-2 px-4 py-2 rounded-full bg-card/50 border border-border/50 text-muted-foreground text-sm\">\n                                            <span className=\"text-emerald-400\">\u2713</span>\n                                            All {images.length} images loaded\n                                        </div>\n                                    </div>\n                                )}\n                            </>\n                        )}\n                    </CardContent>\n\n                    {/* Fullscreen Image Modal */}\n                    {fullscreenImage && (\n                        <FullscreenModal\n                            fullscreenImage={fullscreenImage}\n                            images={images}\n                            setFullscreenImage={setFullscreenImage}\n                            onClose={() => setFullscreenImage(null)}\n                            onNavigate={(direction: 'next' | 'previous') => navigateToImage(direction)}\n                            onCopyImage={handleCopyImage}\n                            onDownloadImage={handleDownloadImage}\n                            onDeleteImage={handleDeleteImage}\n                            onSendTo={currentTab ? (url: string, target: string) => handleSendTo(url, target) : (() => { })}\n                            onSetReference={async () => {\n                                const newRef = await showReferenceNamePrompt()\n                                if (newRef) {\n                                    await updateImageReference(fullscreenImage.id, newRef)\n                                }\n                            }}\n                            onAddToLibrary={onSendToLibrary && fullscreenImage ? () => onSendToLibrary(fullscreenImage.url, fullscreenImage.id) : undefined}\n                            onExtractFrames={() => handleExtractFrames(fullscreenImage.url)}\n                            onExtractFramesToGallery={() => handleExtractFramesToGallery(fullscreenImage.url, fullscreenImage.id)}\n                            onRemoveBackground={() => handleRemoveBackground(fullscreenImage)}\n                            isRemovingBackground={removingBackgroundId === fullscreenImage.id}\n                            onGenerateCinematicGrid={() => handleGenerateCinematicGrid(fullscreenImage)}\n                            isGeneratingCinematic={generatingCinematicId === fullscreenImage.id}\n                            showReferenceNamePrompt={showReferenceNamePrompt}\n                        />\n                    )}\n\n                    {/* Bulk Download Modal */}\n                    <BulkDownloadModal\n                        open={downloadModalOpen}\n                        onOpenChange={setDownloadModalOpen}\n                        imageCount={selectedImages.length}\n                        current={downloadProgress?.current || 0}\n                        status={downloadProgress?.status || 'downloading'}\n                        error={downloadProgress?.error}\n                    />\n                </Card>\n\n                {/* Bulk Actions Toolbar - floating at bottom of viewport when items selected */}\n                <BulkActionsToolbar\n                    selectedCount={selectedImages.length}\n                    folders={folders}\n                    onClearSelection={handleClearSelection}\n                    onDownloadZip={handleBulkDownload}\n                    onMoveToFolder={handleBulkMoveToFolder}\n                    onCreateFolder={openCreateModal}\n                    onDelete={handleDeleteSelected}\n                />\n            </div>\n        </>\n    )\n}",
        "last_modified": "2025-12-25T18:57:10.945483"
      },
      "task_intent": {
        "title": "013-multi-select-gallery-with-bulk-actions",
        "description": "Add multi-select mode to the unified image gallery with bulk actions toolbar (Download ZIP, Delete Selected, Move to Folder). Enable Shift+click for range selection and Ctrl+click for toggle selection.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T18:55:48.939508",
  "last_updated": "2025-12-25T18:57:10.820408"
}