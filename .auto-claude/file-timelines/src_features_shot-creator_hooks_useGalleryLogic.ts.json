{
  "file_path": "src/features/shot-creator/hooks/useGalleryLogic.ts",
  "main_branch_history": [],
  "task_views": {
    "013-multi-select-gallery-with-bulk-actions": {
      "task_id": "013-multi-select-gallery-with-bulk-actions",
      "branch_point": {
        "commit_hash": "8654231a22984c33942f63d8839bdca5b0d017c2",
        "content": "'use client'\n\nimport { useState, useCallback } from 'react'\nimport { useUnifiedGalleryStore } from '../store/unified-gallery-store'\nimport { useToast } from '@/hooks/use-toast'\nimport { clipboardManager } from '@/utils/clipboard-manager'\nimport { haptics } from '@/utils/haptics'\nimport { BulkDownloadService, DownloadProgress } from '../services/bulk-download.service'\n\nexport type ViewMode = 'grid'\n\nexport interface GalleryFilters {\n  searchQuery: string\n  viewMode: ViewMode\n}\nexport function useGalleryLogic(\n  onSendToTab?: (imageUrl: string, targetTab: string) => void,\n  onUseAsReference?: (imageUrl: string) => void,\n  onSendToShotAnimator?: (imageUrl: string) => void,\n  onSendToLayoutAnnotation?: (imageUrl: string) => void,\n  onSendToLibrary?: (imageUrl: string, galleryId: string) => void,\n  onImageSelect?: (imageUrl: string) => void\n) {\n  const { toast } = useToast()\n  const {\n    images,\n    removeImage,\n    setFullscreenImage,\n    fullscreenImage,\n    getTotalImages,\n    getTotalCreditsUsed,\n    updateImageReference,\n    totalPages: storeTotalPages,\n    setCurrentPage: storeSetCurrentPage,\n    searchQuery,\n    setSearchQuery\n  } = useUnifiedGalleryStore()\n\n  // State\n  const [selectedImages, setSelectedImages] = useState<string[]>([])\n  // We only keep viewMode locally as it's UI preference\n  const [viewMode, setViewMode] = useState<ViewMode>('grid')\n\n  const [downloadModalOpen, setDownloadModalOpen] = useState(false)\n  const [downloadProgress, setDownloadProgress] = useState<DownloadProgress | null>(null)\n\n  // Use images directly from store (server-side filtered)\n  const paginatedImages = images\n  const totalPages = storeTotalPages\n\n  // Handlers\n  const handleImageSelect = useCallback((imageUrl: string) => {\n    if (onImageSelect) {\n      onImageSelect(imageUrl)\n    } else {\n      setSelectedImages(prev =>\n        prev.includes(imageUrl)\n          ? prev.filter(url => url !== imageUrl)\n          : [...prev, imageUrl]\n      )\n    }\n  }, [onImageSelect])\n\n  const handleClearSelection = () => {\n    setSelectedImages([])\n  }\n\n  const handleSelectAll = () => {\n    setSelectedImages(paginatedImages.map(img => img.url))\n  }\n\n  const handleDeleteSelected = async () => {\n    let successCount = 0\n    let failedCount = 0\n\n    // Delete images in parallel, but await all results\n    const results = await Promise.all(\n      selectedImages.map(async (url) => {\n        const success = await removeImage(url)\n        return success\n      })\n    )\n\n    results.forEach(success => {\n      if (success) {\n        successCount++\n      } else {\n        failedCount++\n      }\n    })\n\n    setSelectedImages([])\n\n    if (failedCount === 0) {\n      toast({\n        title: \"Images Deleted Permanently\",\n        description: `${successCount} images removed from database and storage`\n      })\n    } else if (successCount === 0) {\n      toast({\n        title: \"Delete Failed\",\n        description: `Failed to delete ${failedCount} images. Please try again.`,\n        variant: \"destructive\"\n      })\n    } else {\n      toast({\n        title: \"Partial Delete\",\n        description: `Deleted ${successCount} images, but ${failedCount} failed.`,\n        variant: \"destructive\"\n      })\n    }\n  }\n\n  const handleCopyImage = async (url: string) => {\n    try {\n      const response = await fetch(url)\n      const blob = await response.blob()\n\n      // Convert image to PNG for clipboard compatibility\n      if (blob.type !== 'image/png') {\n        // Create an image element to convert the format\n        const img = new Image()\n        const objectUrl = URL.createObjectURL(blob)\n\n        await new Promise((resolve, reject) => {\n          img.onload = resolve\n          img.onerror = reject\n          img.src = objectUrl\n        })\n\n        // Create a canvas and draw the image\n        const canvas = document.createElement('canvas')\n        canvas.width = img.width\n        canvas.height = img.height\n        const ctx = canvas.getContext('2d')\n        if (!ctx) throw new Error('Could not get canvas context')\n\n        ctx.drawImage(img, 0, 0)\n        URL.revokeObjectURL(objectUrl)\n\n        // Convert canvas to PNG data URL\n        const dataURL = canvas.toDataURL('image/png')\n\n        // Copy using clipboardManager\n        await clipboardManager.writeImage(dataURL)\n      } else {\n        // Convert blob to data URL for clipboardManager\n        const reader = new FileReader()\n        const dataURL = await new Promise<string>((resolve, reject) => {\n          reader.onload = () => resolve(reader.result as string)\n          reader.onerror = reject\n          reader.readAsDataURL(blob)\n        })\n\n        await clipboardManager.writeImage(dataURL)\n      }\n\n      toast({\n        title: \"Copied\",\n        description: \"Image copied to clipboard\"\n      })\n    } catch (error) {\n      console.error(\"Copy failed\", error)\n      // Fallback: try to copy URL instead\n      try {\n        await clipboardManager.writeText(url)\n        toast({\n          title: \"Copied URL\",\n          description: \"Image URL copied to clipboard (image format not supported)\"\n        })\n      } catch {\n        toast({\n          title: \"Copy Failed\",\n          description: \"Unable to copy to clipboard\",\n          variant: \"destructive\"\n        })\n      }\n    }\n  }\n\n  const handleDownloadImage = async (url: string) => {\n    try {\n      // Fetch the image as a blob\n      const response = await fetch(url, { mode: \"cors\" })\n      const blob = await response.blob()\n\n      // Create a local object URL for the blob\n      const objectUrl = URL.createObjectURL(blob)\n\n      // Create a hidden <a> tag and click it\n      const a = document.createElement(\"a\")\n      a.href = objectUrl\n      a.download = `image_${Date.now()}.png`\n      document.body.appendChild(a)\n      a.click()\n      document.body.removeChild(a)\n\n      // Cleanup the object URL\n      URL.revokeObjectURL(objectUrl)\n\n      toast({\n        title: \"Download started\",\n        description: \"Your image is downloading\"\n      })\n    } catch (err) {\n      console.error(\"Download failed\", err)\n      toast({\n        title: \"Download failed\",\n        description: \"Could not download image\",\n        variant: \"destructive\"\n      })\n    }\n  }\n\n  const handleDeleteImage = async (imageUrl: string) => {\n    const success = await removeImage(imageUrl)\n    if (success) {\n      setSelectedImages(prev => prev.filter(url => url !== imageUrl))\n      toast({\n        title: \"Image Deleted Permanently\",\n        description: \"Removed from database and storage\"\n      })\n    } else {\n      toast({\n        title: \"Deletion Failed\",\n        description: \"Could not delete image\",\n        variant: \"destructive\"\n      })\n    }\n  }\n\n  const handleSendTo = (imageUrl: string, target: string) => {\n    if ((target === 'reference' || target === 'shot-creator') && onUseAsReference) {\n      onUseAsReference(imageUrl)\n      return\n    } else if (target === 'shot-animator' && onSendToShotAnimator) {\n      onSendToShotAnimator(imageUrl)\n      return\n    } else if (target === 'layout-annotation' && onSendToLayoutAnnotation) {\n      onSendToLayoutAnnotation(imageUrl)\n      return\n    } else if (onSendToTab) {\n      onSendToTab(imageUrl, target)\n    } else if (target === 'library' && onSendToLibrary) {\n      // Find the image to get its gallery ID\n      const image = images.find(img => img.url === imageUrl)\n      if (image) {\n        onSendToLibrary(imageUrl, image.id)\n      } else {\n        toast({\n          title: \"Error\",\n          description: \"Could not find image in gallery\",\n          variant: \"destructive\"\n        })\n        return\n      }\n    }\n\n    toast({\n      title: \"Image Sent\",\n      description: `Image sent to ${target}`\n    })\n  }\n  const handleSearchChange = (query: string) => {\n    // Debouncing could be added here or in the UI component\n    setSearchQuery(query)\n  }\n\n  const handleViewModeChange = (mode: ViewMode) => {\n    setViewMode(mode)\n  }\n\n  const handlePageChange = (page: number) => {\n    storeSetCurrentPage(page)\n  }\n\n  const handleUpdateImageReference = async (imageId: string, reference: string) => {\n    try {\n      await updateImageReference(imageId, reference)\n      // Haptic feedback for mobile\n      haptics.success()\n      toast({\n        title: \"Reference Updated\",\n        description: `Image reference set to ${reference.startsWith('@') ? reference : `@${reference}`}`\n      })\n    } catch (error) {\n      console.error('Failed to update reference:', error)\n      // Error haptic for mobile\n      haptics.error()\n      toast({\n        title: \"Update Failed\",\n        description: \"Could not update image reference\",\n        variant: \"destructive\"\n      })\n    }\n  }\n\n  const handleBulkDownload = async () => {\n    if (selectedImages.length === 0) return\n\n    setDownloadModalOpen(true)\n\n    const imagesToDownload = images\n      .filter(img => selectedImages.includes(img.url))\n      .map(img => ({ url: img.url, id: img.id }))\n\n    try {\n      await BulkDownloadService.downloadAsZip(\n        imagesToDownload,\n        undefined, // use default name\n        (progress) => setDownloadProgress(progress)\n      )\n    } catch (error) {\n      console.error('Bulk download failed:', error)\n      toast({\n        title: 'Download Failed',\n        description: error instanceof Error ? error.message : 'Failed to download images',\n        variant: 'destructive'\n      })\n    }\n  }\n\n  return {\n    // Data\n    images,\n    filteredImages: images, // Logic is now server-side, so images ARE the filtered images\n    paginatedImages,\n    totalPages,\n    selectedImages,\n    filters: {\n      searchQuery: searchQuery,\n      viewMode: viewMode\n    },\n    fullscreenImage,\n\n    // Stats\n    totalImages: getTotalImages(),\n    totalCredits: getTotalCreditsUsed(),\n\n    // Handlers\n    handleImageSelect,\n    handleSelectAll,\n    handleClearSelection,\n    handleDeleteSelected,\n    handleCopyImage,\n    handleDownloadImage,\n    handleDeleteImage,\n    handleSendTo,\n    handleSearchChange,\n    handleViewModeChange,\n    handlePageChange,\n    setFullscreenImage,\n    updateImageReference: handleUpdateImageReference,\n\n    // Bulk Download\n    downloadModalOpen,\n    downloadProgress,\n    handleBulkDownload,\n    setDownloadModalOpen\n  }\n}",
        "timestamp": "2025-12-25T18:57:10.314069"
      },
      "worktree_state": {
        "content": "'use client'\n\nimport { useState, useCallback, useMemo } from 'react'\nimport { useUnifiedGalleryStore } from '../store/unified-gallery-store'\nimport { useToast } from '@/hooks/use-toast'\nimport { clipboardManager } from '@/utils/clipboard-manager'\nimport { haptics } from '@/utils/haptics'\nimport { BulkDownloadService, DownloadProgress } from '../services/bulk-download.service'\nimport { useGallerySelection } from './useGallerySelection'\n\nexport type ViewMode = 'grid'\n\nexport interface GalleryFilters {\n  searchQuery: string\n  viewMode: ViewMode\n}\nexport function useGalleryLogic(\n  onSendToTab?: (imageUrl: string, targetTab: string) => void,\n  onUseAsReference?: (imageUrl: string) => void,\n  onSendToShotAnimator?: (imageUrl: string) => void,\n  onSendToLayoutAnnotation?: (imageUrl: string) => void,\n  onSendToLibrary?: (imageUrl: string, galleryId: string) => void,\n  onImageSelect?: (imageUrl: string) => void\n) {\n  const { toast } = useToast()\n  const {\n    images,\n    removeImage,\n    setFullscreenImage,\n    fullscreenImage,\n    getTotalImages,\n    getTotalCreditsUsed,\n    updateImageReference,\n    totalPages: storeTotalPages,\n    setCurrentPage: storeSetCurrentPage,\n    searchQuery,\n    setSearchQuery\n  } = useUnifiedGalleryStore()\n\n  // Selection state using Set-based hook for efficient operations\n  const {\n    selectedIds,\n    selectedCount,\n    selectAll: selectAllIds,\n    selectNone,\n    toggleSelect,\n    isSelected,\n    handleSelectWithModifiers\n  } = useGallerySelection()\n\n  // Derive selectedImages array from selectedIds Set for backward compatibility\n  // The selection uses image URLs for consistency with existing handlers\n  const selectedImages = useMemo(() => Array.from(selectedIds), [selectedIds])\n\n  // We only keep viewMode locally as it's UI preference\n  const [viewMode, setViewMode] = useState<ViewMode>('grid')\n\n  const [downloadModalOpen, setDownloadModalOpen] = useState(false)\n  const [downloadProgress, setDownloadProgress] = useState<DownloadProgress | null>(null)\n\n  // Use images directly from store (server-side filtered)\n  const paginatedImages = images\n  const totalPages = storeTotalPages\n\n  // Handlers\n  const handleImageSelect = useCallback((imageUrl: string) => {\n    if (onImageSelect) {\n      onImageSelect(imageUrl)\n    } else {\n      toggleSelect(imageUrl)\n    }\n  }, [onImageSelect, toggleSelect])\n\n  /**\n   * Handle selection with modifier keys (Shift+click for range, Ctrl/Cmd+click for toggle).\n   * Pass the ordered images array for range selection to work correctly.\n   */\n  const handleImageSelectWithModifiers = useCallback((\n    imageUrl: string,\n    event: React.MouseEvent\n  ) => {\n    if (onImageSelect) {\n      // If custom handler provided, just call it (no modifier key support)\n      onImageSelect(imageUrl)\n    } else {\n      // Use the ordered images from the paginated view for range selection\n      handleSelectWithModifiers(imageUrl, paginatedImages.map(img => img.url), event)\n    }\n  }, [onImageSelect, handleSelectWithModifiers, paginatedImages])\n\n  const handleClearSelection = useCallback(() => {\n    selectNone()\n  }, [selectNone])\n\n  const handleSelectAll = useCallback(() => {\n    selectAllIds(paginatedImages.map(img => img.url))\n  }, [selectAllIds, paginatedImages])\n\n  const handleDeleteSelected = async () => {\n    let successCount = 0\n    let failedCount = 0\n\n    // Delete images in parallel, but await all results\n    const results = await Promise.all(\n      selectedImages.map(async (url) => {\n        const success = await removeImage(url)\n        return success\n      })\n    )\n\n    results.forEach(success => {\n      if (success) {\n        successCount++\n      } else {\n        failedCount++\n      }\n    })\n\n    selectNone()\n\n    if (failedCount === 0) {\n      toast({\n        title: \"Images Deleted Permanently\",\n        description: `${successCount} images removed from database and storage`\n      })\n    } else if (successCount === 0) {\n      toast({\n        title: \"Delete Failed\",\n        description: `Failed to delete ${failedCount} images. Please try again.`,\n        variant: \"destructive\"\n      })\n    } else {\n      toast({\n        title: \"Partial Delete\",\n        description: `Deleted ${successCount} images, but ${failedCount} failed.`,\n        variant: \"destructive\"\n      })\n    }\n  }\n\n  const handleCopyImage = async (url: string) => {\n    try {\n      const response = await fetch(url)\n      const blob = await response.blob()\n\n      // Convert image to PNG for clipboard compatibility\n      if (blob.type !== 'image/png') {\n        // Create an image element to convert the format\n        const img = new Image()\n        const objectUrl = URL.createObjectURL(blob)\n\n        await new Promise((resolve, reject) => {\n          img.onload = resolve\n          img.onerror = reject\n          img.src = objectUrl\n        })\n\n        // Create a canvas and draw the image\n        const canvas = document.createElement('canvas')\n        canvas.width = img.width\n        canvas.height = img.height\n        const ctx = canvas.getContext('2d')\n        if (!ctx) throw new Error('Could not get canvas context')\n\n        ctx.drawImage(img, 0, 0)\n        URL.revokeObjectURL(objectUrl)\n\n        // Convert canvas to PNG data URL\n        const dataURL = canvas.toDataURL('image/png')\n\n        // Copy using clipboardManager\n        await clipboardManager.writeImage(dataURL)\n      } else {\n        // Convert blob to data URL for clipboardManager\n        const reader = new FileReader()\n        const dataURL = await new Promise<string>((resolve, reject) => {\n          reader.onload = () => resolve(reader.result as string)\n          reader.onerror = reject\n          reader.readAsDataURL(blob)\n        })\n\n        await clipboardManager.writeImage(dataURL)\n      }\n\n      toast({\n        title: \"Copied\",\n        description: \"Image copied to clipboard\"\n      })\n    } catch (error) {\n      console.error(\"Copy failed\", error)\n      // Fallback: try to copy URL instead\n      try {\n        await clipboardManager.writeText(url)\n        toast({\n          title: \"Copied URL\",\n          description: \"Image URL copied to clipboard (image format not supported)\"\n        })\n      } catch {\n        toast({\n          title: \"Copy Failed\",\n          description: \"Unable to copy to clipboard\",\n          variant: \"destructive\"\n        })\n      }\n    }\n  }\n\n  const handleDownloadImage = async (url: string) => {\n    try {\n      // Fetch the image as a blob\n      const response = await fetch(url, { mode: \"cors\" })\n      const blob = await response.blob()\n\n      // Create a local object URL for the blob\n      const objectUrl = URL.createObjectURL(blob)\n\n      // Create a hidden <a> tag and click it\n      const a = document.createElement(\"a\")\n      a.href = objectUrl\n      a.download = `image_${Date.now()}.png`\n      document.body.appendChild(a)\n      a.click()\n      document.body.removeChild(a)\n\n      // Cleanup the object URL\n      URL.revokeObjectURL(objectUrl)\n\n      toast({\n        title: \"Download started\",\n        description: \"Your image is downloading\"\n      })\n    } catch (err) {\n      console.error(\"Download failed\", err)\n      toast({\n        title: \"Download failed\",\n        description: \"Could not download image\",\n        variant: \"destructive\"\n      })\n    }\n  }\n\n  const handleDeleteImage = async (imageUrl: string) => {\n    const success = await removeImage(imageUrl)\n    if (success) {\n      // Remove from selection if it was selected\n      if (isSelected(imageUrl)) {\n        toggleSelect(imageUrl)\n      }\n      toast({\n        title: \"Image Deleted Permanently\",\n        description: \"Removed from database and storage\"\n      })\n    } else {\n      toast({\n        title: \"Deletion Failed\",\n        description: \"Could not delete image\",\n        variant: \"destructive\"\n      })\n    }\n  }\n\n  const handleSendTo = (imageUrl: string, target: string) => {\n    if ((target === 'reference' || target === 'shot-creator') && onUseAsReference) {\n      onUseAsReference(imageUrl)\n      return\n    } else if (target === 'shot-animator' && onSendToShotAnimator) {\n      onSendToShotAnimator(imageUrl)\n      return\n    } else if (target === 'layout-annotation' && onSendToLayoutAnnotation) {\n      onSendToLayoutAnnotation(imageUrl)\n      return\n    } else if (onSendToTab) {\n      onSendToTab(imageUrl, target)\n    } else if (target === 'library' && onSendToLibrary) {\n      // Find the image to get its gallery ID\n      const image = images.find(img => img.url === imageUrl)\n      if (image) {\n        onSendToLibrary(imageUrl, image.id)\n      } else {\n        toast({\n          title: \"Error\",\n          description: \"Could not find image in gallery\",\n          variant: \"destructive\"\n        })\n        return\n      }\n    }\n\n    toast({\n      title: \"Image Sent\",\n      description: `Image sent to ${target}`\n    })\n  }\n  const handleSearchChange = (query: string) => {\n    // Debouncing could be added here or in the UI component\n    setSearchQuery(query)\n  }\n\n  const handleViewModeChange = (mode: ViewMode) => {\n    setViewMode(mode)\n  }\n\n  const handlePageChange = (page: number) => {\n    storeSetCurrentPage(page)\n  }\n\n  const handleUpdateImageReference = async (imageId: string, reference: string) => {\n    try {\n      await updateImageReference(imageId, reference)\n      // Haptic feedback for mobile\n      haptics.success()\n      toast({\n        title: \"Reference Updated\",\n        description: `Image reference set to ${reference.startsWith('@') ? reference : `@${reference}`}`\n      })\n    } catch (error) {\n      console.error('Failed to update reference:', error)\n      // Error haptic for mobile\n      haptics.error()\n      toast({\n        title: \"Update Failed\",\n        description: \"Could not update image reference\",\n        variant: \"destructive\"\n      })\n    }\n  }\n\n  const handleBulkDownload = async () => {\n    if (selectedImages.length === 0) return\n\n    setDownloadModalOpen(true)\n\n    const imagesToDownload = images\n      .filter(img => selectedImages.includes(img.url))\n      .map(img => ({ url: img.url, id: img.id }))\n\n    try {\n      await BulkDownloadService.downloadAsZip(\n        imagesToDownload,\n        undefined, // use default name\n        (progress) => setDownloadProgress(progress)\n      )\n    } catch (error) {\n      console.error('Bulk download failed:', error)\n      toast({\n        title: 'Download Failed',\n        description: error instanceof Error ? error.message : 'Failed to download images',\n        variant: 'destructive'\n      })\n    }\n  }\n\n  return {\n    // Data\n    images,\n    filteredImages: images, // Logic is now server-side, so images ARE the filtered images\n    paginatedImages,\n    totalPages,\n    selectedImages,\n    selectedCount, // Number of selected images (from useGallerySelection)\n    isSelected, // Check if a specific image is selected\n    filters: {\n      searchQuery: searchQuery,\n      viewMode: viewMode\n    },\n    fullscreenImage,\n\n    // Stats\n    totalImages: getTotalImages(),\n    totalCredits: getTotalCreditsUsed(),\n\n    // Handlers\n    handleImageSelect,\n    handleImageSelectWithModifiers, // Selection with Shift/Ctrl modifier key support\n    handleSelectAll,\n    handleClearSelection,\n    handleDeleteSelected,\n    handleCopyImage,\n    handleDownloadImage,\n    handleDeleteImage,\n    handleSendTo,\n    handleSearchChange,\n    handleViewModeChange,\n    handlePageChange,\n    setFullscreenImage,\n    updateImageReference: handleUpdateImageReference,\n\n    // Bulk Download\n    downloadModalOpen,\n    downloadProgress,\n    handleBulkDownload,\n    setDownloadModalOpen\n  }\n}",
        "last_modified": "2025-12-25T19:32:48.525165"
      },
      "task_intent": {
        "title": "013-multi-select-gallery-with-bulk-actions",
        "description": "Add multi-select mode to the unified image gallery with bulk actions toolbar (Download ZIP, Delete Selected, Move to Folder). Enable Shift+click for range selection and Ctrl+click for toggle selection.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-25T18:55:48.990638",
  "last_updated": "2025-12-25T18:57:10.875852"
}